{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PL/SQL Interview Guide","text":"<p>This guide covers SQL, PL/SQL, and Interview Questions. Click below to start exploring \ud83d\udc47</p>"},{"location":"#sections","title":"\ud83d\udcd6 Sections","text":"<ul> <li>Introduction</li> <li>SQL Interview Questions</li> <li>PL/SQL Basics</li> </ul> <p>\ud83d\udca1 Tip: Use the navigation bar at the top for quick access to all topics.</p>"},{"location":"#deploy-to-gh-pages-branch","title":"Deploy to gh-pages branch","text":"<p>mkdocs gh-deploy</p>"},{"location":"Interview/1.Introduction/","title":"Introduction","text":"<p>Hi, I am __, working as a PL/SQL Developer with around 4 years of experience in SQL and PL/SQL development using Oracle 12c/19c. I have worked on development, enhancement, and support projects in domains like Banking, Retail, and Sales.  </p> <p>My expertise includes: - Writing complex SQL queries, stored procedures, functions, packages, and triggers. - SQL performance tuning, exception handling, bulk operations, and data loading using SQL*Loader. - Data modeling (Star and Snowflake schema). - BI reporting tools like QlikView and BI Publisher. - Working in Agile methodology.  </p> <p>I am also involved in client interactions for requirement gathering, effort estimation, and providing regular updates.  </p>"},{"location":"Interview/1.Introduction/#day-to-day-activities-story-style","title":"Day-to-Day Activities (Story Style)","text":"<p>In my project, my day usually starts with a stand-up meeting where I update the team on my progress and plan the day\u2019s work. After that, I check tickets and production logs to see if any jobs or procedures have failed.  </p> <p>Most of my time goes into developing and enhancing PL/SQL objects like procedures, functions, packages, and triggers to meet business requirements. I also work on data loading using SQL*Loader and design database objects such as tables and views when needed.  </p> <p>Alongside development, I spend time testing and debugging the code, optimizing queries for better performance, and fixing any production issues reported by users. I also interact with business analysts and clients to clarify requirements and provide effort estimates.  </p> <p>By the end of the day, I update the task tracker, document the changes, and share my status with the team.  </p>"},{"location":"Interview/2.sql/","title":"Oracle SQL Concepts Organized by Categories","text":""},{"location":"Interview/2.sql/#fundamentals","title":"FUNDAMENTALS","text":"Concept Definition SQL (Structured Query Language) Standard language for accessing and manipulating relational databases, with Oracle-specific extensions. DDL (Data Definition Language) SQL commands that define database structure: CREATE, ALTER, DROP, TRUNCATE, COMMENT, RENAME. DML (Data Manipulation Language) SQL commands that manipulate data: INSERT, UPDATE, DELETE, SELECT, MERGE. DCL (Data Control Language) SQL commands that control access: GRANT, REVOKE. TCL (Transaction Control Language) SQL commands that manage transactions: COMMIT, ROLLBACK, SAVEPOINT. Schema Logical container that owns database objects like tables, views, indexes, etc. Database Object Any structure stored in the database like tables, views, indexes, sequences, synonyms, etc."},{"location":"Interview/2.sql/#data-types","title":"DATA TYPES","text":"Concept Definition VARCHAR2 Variable-length character string datatype, most commonly used string type in Oracle. CHAR Fixed-length character string datatype that pads with spaces. NUMBER Numeric datatype that can store integers and floating-point numbers with specified precision and scale. DATE Datatype for storing date and time information (century to second precision). TIMESTAMP Enhanced date datatype with fractional seconds precision and optional timezone information. CLOB Character Large Object for storing large amounts of character data (up to 4GB). BLOB Binary Large Object for storing large amounts of binary data (up to 4GB). NCHAR/NVARCHAR2 National character datatypes supporting Unicode character sets. RAW Datatype for storing binary data in hexadecimal format. ROWID Pseudo-datatype containing the physical address of a row in the database. XMLType Datatype specifically designed for storing and manipulating XML data."},{"location":"Interview/2.sql/#tables-and-constraints","title":"TABLES AND CONSTRAINTS","text":"Concept Definition Table Basic storage unit in Oracle database consisting of rows and columns. Primary Key Constraint that uniquely identifies each row in a table, cannot be NULL. Foreign Key Constraint that establishes referential integrity between tables. Unique Constraint Constraint that ensures all values in a column or combination of columns are unique. Check Constraint Constraint that validates data based on specified conditions before insertion/update. NOT NULL Constraint Constraint that prevents NULL values from being stored in a column. Default Value Value automatically assigned to a column when no value is explicitly provided. Temporary Table Table that stores data temporarily, either for session or transaction duration. External Table Table structure that allows querying external files as if they were database tables. Partitioned Table Table divided into smaller, manageable segments based on column values."},{"location":"Interview/2.sql/#basic-sql-operations","title":"BASIC SQL OPERATIONS","text":"Concept Definition SELECT DML command used to retrieve data from one or more tables. INSERT DML command used to add new rows to a table. UPDATE DML command used to modify existing rows in a table. DELETE DML command used to remove rows from a table. MERGE DML command that combines INSERT, UPDATE, and DELETE operations in a single statement. WHERE Clause Clause used to filter rows based on specified conditions. ORDER BY Clause used to sort query results in ascending or descending order. GROUP BY Clause used to group rows with similar values for aggregate functions. HAVING Clause used to filter groups created by GROUP BY based on aggregate conditions. DISTINCT Keyword used to eliminate duplicate rows from query results."},{"location":"Interview/2.sql/#joins","title":"JOINS","text":"Concept Definition Inner Join Returns rows that have matching values in both tables being joined. Left Outer Join Returns all rows from the left table and matched rows from the right table. Right Outer Join Returns all rows from the right table and matched rows from the left table. Full Outer Join Returns all rows from both tables, including unmatched rows. Cross Join Returns the Cartesian product of two tables (all possible combinations). Self Join Join operation where a table is joined with itself. Natural Join Join that automatically joins tables based on columns with the same name and datatype. Join Condition Condition that specifies how tables are related in a join operation. Equijoin Join based on equality comparison between columns from different tables. Non-Equijoin Join based on non-equality conditions like greater than, less than, etc."},{"location":"Interview/2.sql/#functions","title":"FUNCTIONS","text":"Concept Definition Single-Row Functions Functions that operate on individual rows and return one result per row. Aggregate Functions Functions that operate on groups of rows and return a single result per group. Character Functions Functions that manipulate character data: UPPER, LOWER, SUBSTR, LENGTH, TRIM, etc. Number Functions Functions that perform mathematical operations: ROUND, TRUNC, ABS, MOD, POWER, etc. Date Functions Functions that manipulate date data: SYSDATE, ADD_MONTHS, MONTHS_BETWEEN, TRUNC, etc. Conversion Functions Functions that convert data from one type to another: TO_CHAR, TO_NUMBER, TO_DATE, etc. NULL Functions Functions that handle NULL values: NVL, NVL2, NULLIF, COALESCE. Analytical Functions Functions that perform calculations across related rows: ROW_NUMBER, RANK, LAG, LEAD, etc. Regular Expression Functions Functions for pattern matching: REGEXP_LIKE, REGEXP_REPLACE, REGEXP_SUBSTR, etc."},{"location":"Interview/2.sql/#subqueries","title":"SUBQUERIES","text":"Concept Definition Subquery Query nested inside another SQL statement, also called inner query or nested query. Scalar Subquery Subquery that returns exactly one row and one column. Multi-row Subquery Subquery that returns multiple rows but single column. Multi-column Subquery Subquery that returns multiple columns and potentially multiple rows. Correlated Subquery Subquery that references columns from the outer query. Non-correlated Subquery Subquery that can be executed independently of the outer query. EXISTS Operator used to test whether a subquery returns any rows. IN/NOT IN Operators used to test whether a value matches any value in a subquery result. ANY/SOME Operators used to compare a value with any value returned by a subquery. ALL Operator used to compare a value with all values returned by a subquery."},{"location":"Interview/2.sql/#indexes","title":"INDEXES","text":"Concept Definition Index Database object that improves query performance by providing faster data access paths. B-tree Index Most common index type that organizes data in a balanced tree structure. Bitmap Index Index type suitable for columns with low cardinality and data warehouse environments. Unique Index Index that ensures uniqueness of indexed column values. Composite Index Index created on multiple columns of a table. Function-based Index Index created on the result of a function or expression rather than column values. Partial Index Index created on a subset of rows based on a WHERE condition. Reverse Key Index B-tree index where key values are stored in reverse to reduce contention. Index Organized Table (IOT) Table where data is stored in the index structure itself. Invisible Index Index that exists but is ignored by the optimizer unless specifically requested."},{"location":"Interview/2.sql/#views","title":"VIEWS","text":"Concept Definition View Virtual table based on the result of a SQL query, doesn't store data physically. Simple View View based on a single table without complex operations like joins or functions. Complex View View based on multiple tables or containing functions, expressions, or GROUP BY. Updatable View View that allows INSERT, UPDATE, DELETE operations under certain conditions. Materialized View Physical copy of view data stored in the database for performance improvement. Materialized View Log Table that tracks changes to base tables for fast refresh of materialized views. Refresh Methods Techniques for updating materialized views: FAST, COMPLETE, FORCE refresh. View Constraints Constraints that can be defined on views for data validation and integrity."},{"location":"Interview/2.sql/#sequences","title":"SEQUENCES","text":"Concept Definition Sequence Database object that generates unique numeric values automatically. NEXTVAL Pseudo-column that returns the next value from a sequence. CURRVAL Pseudo-column that returns the current value from a sequence in the session. START WITH Parameter that specifies the first value generated by a sequence. INCREMENT BY Parameter that specifies the interval between sequence numbers. MAXVALUE/MINVALUE Parameters that specify the maximum and minimum values for a sequence. CYCLE/NOCYCLE Parameter that determines whether sequence values restart after reaching limits. CACHE/NOCACHE Parameter that controls whether sequence values are pre-allocated in memory."},{"location":"Interview/2.sql/#synonyms","title":"SYNONYMS","text":"Concept Definition Synonym Alternative name for database objects like tables, views, sequences, etc. Private Synonym Synonym accessible only to the user who created it. Public Synonym Synonym accessible to all database users. Schema Qualification Specifying the schema name along with object name to avoid ambiguity."},{"location":"Interview/2.sql/#transactions","title":"TRANSACTIONS","text":"Concept Definition Transaction Logical unit of work consisting of one or more SQL statements that succeed or fail as a group. ACID Properties Atomicity, Consistency, Isolation, Durability - fundamental properties of database transactions. COMMIT Command that makes all changes in the current transaction permanent. ROLLBACK Command that undoes all changes made in the current transaction. SAVEPOINT Named point within a transaction to which you can rollback without affecting the entire transaction. Autocommit Feature that automatically commits each SQL statement individually. Read Consistency Oracle's guarantee that queries see a consistent view of data as of query start time. Isolation Levels Different levels of transaction isolation: READ COMMITTED, SERIALIZABLE, READ ONLY."},{"location":"Interview/2.sql/#locks-and-concurrency","title":"LOCKS AND CONCURRENCY","text":"Concept Definition Lock Mechanism to prevent concurrent access conflicts when multiple users access the same data. Row-level Locking Oracle's default locking mechanism that locks only the affected rows. Table Lock Lock that affects an entire table, can be shared or exclusive. Deadlock Situation where two or more transactions wait for each other to release locks. Lock Escalation Process where multiple row locks are converted to table locks (rare in Oracle). SELECT FOR UPDATE Statement that locks selected rows to prevent other users from modifying them. NOWAIT Option that returns immediately if requested locks cannot be obtained. Lock Timeout Feature that automatically releases locks after a specified time period."},{"location":"Interview/2.sql/#performance-optimization","title":"PERFORMANCE OPTIMIZATION","text":"Concept Definition Query Optimizer Component that determines the most efficient execution plan for SQL statements. Cost-Based Optimizer (CBO) Optimizer that uses statistics to calculate the cost of different execution plans. Execution Plan Step-by-step instructions that Oracle follows to execute a SQL statement. Explain Plan Command used to display the execution plan without actually running the query. Hints Directives that provide the optimizer with additional information about how to execute a statement. Table Statistics Information about table data distribution used by the optimizer. Histogram Detailed statistics about data distribution in columns with skewed values. Cardinality Estimated number of rows that a query or operation will return. Selectivity Fraction of rows that satisfy a particular condition. Access Path Method used to retrieve data from tables (full table scan, index scan, etc.)."},{"location":"Interview/2.sql/#analytical-functions","title":"ANALYTICAL FUNCTIONS","text":"Concept Definition Window Functions Functions that perform calculations across related rows without collapsing the result set. PARTITION BY Clause that divides result set into partitions for window function calculations. ORDER BY (in window) Clause that specifies the order of rows within each partition for window functions. ROW_NUMBER() Function that assigns unique sequential numbers to rows within partitions. RANK()/DENSE_RANK() Functions that assign ranking values to rows, handling ties differently. LAG/LEAD Functions that access data from previous or following rows within the same result set. FIRST_VALUE/LAST_VALUE Functions that return the first or last value within a window frame. Running Totals Cumulative calculations performed using window functions with appropriate frames. Moving Averages Calculations that average values over a sliding window of rows."},{"location":"Interview/2.sql/#hierarchical-queries","title":"HIERARCHICAL QUERIES","text":"Concept Definition CONNECT BY Oracle-specific clause for querying hierarchical data structures. START WITH Clause that specifies the root rows for hierarchical queries. PRIOR Operator used in CONNECT BY to reference parent row columns. LEVEL Pseudo-column that indicates the depth level in a hierarchy. SYS_CONNECT_BY_PATH Function that returns the path from root to current row in hierarchical queries. CONNECT_BY_ROOT Operator that returns the root value for the current row in a hierarchy. NOCYCLE Parameter that prevents infinite loops in hierarchical queries."},{"location":"Interview/2.sql/#set-operations","title":"SET OPERATIONS","text":"Concept Definition UNION Set operation that combines results from two queries, eliminating duplicates. UNION ALL Set operation that combines results from two queries, including duplicates. INTERSECT Set operation that returns rows common to both queries. MINUS Set operation that returns rows from the first query that are not in the second query."},{"location":"Interview/2.sql/#advanced-sql-features","title":"ADVANCED SQL FEATURES","text":"Concept Definition Common Table Expression (CTE) WITH clause that defines temporary result sets that can be referenced within a query. Recursive CTE CTE that references itself to process hierarchical or recursive data. CASE Expression Conditional logic that returns different values based on specified conditions. DECODE Function Oracle-specific function that provides if-then-else logic within SQL statements. PIVOT/UNPIVOT Operations that rotate rows to columns and vice versa for data presentation. Model Clause Advanced feature for performing complex calculations and what-if analysis. Flashback Query Feature that allows querying historical data as it existed at a specific point in time. Row Pattern Recognition Advanced feature for pattern matching in sequential data using MATCH_RECOGNIZE."},{"location":"Interview/2.sql/#json-support","title":"JSON SUPPORT","text":"Concept Definition JSON Datatype Native datatype for storing JSON documents with validation and optimization. JSON_VALUE Function for extracting scalar values from JSON data. JSON_QUERY Function for extracting JSON objects or arrays from JSON data. JSON_TABLE Function that converts JSON data into relational rows and columns. JSON_EXISTS Function that tests whether JSON data contains specific paths or values. JSON Path Expression Syntax for navigating and extracting data from JSON documents."},{"location":"Interview/2.sql/#security","title":"SECURITY","text":"Concept Definition Privileges Rights granted to users to perform specific operations on database objects. System Privileges Rights to perform system-level operations like CREATE TABLE, DROP USER, etc. Object Privileges Rights to perform operations on specific database objects like SELECT, INSERT, UPDATE. Roles Named groups of privileges that can be granted to users or other roles. Public Role Special role that is automatically granted to all database users. Grant Command used to give privileges to users or roles. Revoke Command used to remove privileges from users or roles. WITH GRANT OPTION Option that allows the grantee to grant the same privilege to other users."},{"location":"Interview/2.sql/#backup-and-recovery","title":"BACKUP AND RECOVERY","text":"Concept Definition Logical Backup Backup that exports database objects and data in a logical format (Data Pump). Physical Backup Backup that copies actual database files (datafiles, control files, redo logs). Export/Import Utilities for creating logical backups and restoring data (expdp/impdp). Data Pump Advanced export/import technology for high-performance data movement. Flashback Technology that allows recovery of data to a previous point in time. Point-in-Time Recovery Ability to restore database to a specific moment in the past."},{"location":"Interview/2.sql/#data-warehouse-features","title":"DATA WAREHOUSE FEATURES","text":"Concept Definition Star Schema Data warehouse design with fact tables connected to dimension tables. Dimension Tables Tables containing descriptive attributes for analysis. Fact Tables Tables containing measurable business metrics and foreign keys to dimensions. Data Aggregation Process of summarizing detailed data for analytical purposes. OLAP Functions Specialized functions for online analytical processing and business intelligence. Partitioning Technique for dividing large tables into smaller, manageable pieces."},{"location":"Interview/3.plsql/","title":"PL/SQL Syntax Reference Guide with Definitions","text":""},{"location":"Interview/3.plsql/#1-basic-block-structure","title":"1. BASIC BLOCK STRUCTURE","text":"Component Definition Syntax When to Use Anonymous Block Basic unit of PL/SQL code without a name, consists of optional DECLARE, mandatory BEGIN, optional EXCEPTION, and mandatory END sections <code>sql&lt;br&gt;DECLARE&lt;br&gt;  -- variable declarations&lt;br&gt;BEGIN&lt;br&gt;  -- executable statements&lt;br&gt;EXCEPTION&lt;br&gt;  -- exception handlers&lt;br&gt;END;&lt;br&gt;/</code> For simple one-time scripts, testing code, or small tasks that don't need to be stored Named Block PL/SQL block with a label for identification and reference <code>sql&lt;br&gt;&lt;&lt;block_name&gt;&gt;&lt;br&gt;DECLARE&lt;br&gt;  -- declarations&lt;br&gt;BEGIN&lt;br&gt;  -- statements&lt;br&gt;END block_name;</code> When you need to reference the block in GOTO statements or improve code readability Scope The visibility and accessibility of variables within different parts of the program Variables declared in outer blocks are visible in inner blocks Understanding where variables can be accessed and modified Lexical Scoping Rule determining variable visibility based on where variables are declared in nested blocks Inner blocks can access outer block variables, but not vice versa Preventing naming conflicts and controlling variable access"},{"location":"Interview/3.plsql/#2-variables-and-datatypes","title":"2. VARIABLES AND DATATYPES","text":"Concept Definition Syntax When to Use Variable Named storage location that can hold data values, must be declared with a specific datatype <code>sql&lt;br&gt;variable_name datatype [NOT NULL] [:= initial_value];&lt;br&gt;-- Examples:&lt;br&gt;v_name VARCHAR2(50);&lt;br&gt;v_salary NUMBER(8,2) := 5000;&lt;br&gt;v_hire_date DATE NOT NULL := SYSDATE;</code> To store values that can change during program execution Constant A variable whose value cannot be changed once assigned during declaration <code>sql&lt;br&gt;constant_name CONSTANT datatype := value;&lt;br&gt;-- Example:&lt;br&gt;c_tax_rate CONSTANT NUMBER := 0.08;</code> For values that should never change (tax rates, limits, mathematical constants) Datatype Defines the type of data that can be stored in a variable (NUMBER, VARCHAR2, DATE, BOOLEAN, etc.) <code>sql&lt;br&gt;-- Scalar datatypes:&lt;br&gt;v_num NUMBER(10,2);&lt;br&gt;v_text VARCHAR2(100);&lt;br&gt;v_date DATE;&lt;br&gt;v_flag BOOLEAN;</code> To ensure proper data storage and operations on variables %TYPE Attribute Allows a variable to inherit the datatype of a database column or another variable <code>sql&lt;br&gt;v_emp_name employees.first_name%TYPE;&lt;br&gt;v_copy_var v_original_var%TYPE;</code> To ensure variable matches column datatype, maintains consistency when table structure changes %ROWTYPE Attribute Allows a variable to store an entire row from a table or cursor with the same structure <code>sql&lt;br&gt;v_emp_record employees%ROWTYPE;&lt;br&gt;v_cursor_rec cursor_name%ROWTYPE;</code> To store complete row data, useful for copying/processing entire records efficiently Record Composite datatype that groups related data items together, similar to a row in a table <code>sql&lt;br&gt;TYPE emp_record_type IS RECORD (&lt;br&gt;  name VARCHAR2(50),&lt;br&gt;  salary NUMBER,&lt;br&gt;  hire_date DATE&lt;br&gt;);&lt;br&gt;v_emp emp_record_type;</code> To group related data together when you need a custom structure different from existing tables"},{"location":"Interview/3.plsql/#3-control-structures","title":"3. CONTROL STRUCTURES","text":"Structure Definition Syntax When to Use IF-THEN-ELSE Conditional logic structure that executes different code blocks based on conditions <code>sql&lt;br&gt;IF condition THEN&lt;br&gt;  statements;&lt;br&gt;ELSIF condition THEN&lt;br&gt;  statements;&lt;br&gt;ELSE&lt;br&gt;  statements;&lt;br&gt;END IF;</code> For conditional logic with multiple branches or complex decision making CASE Statement Control structure that selects one of many code blocks to execute based on expression value <code>sql&lt;br&gt;CASE variable&lt;br&gt;  WHEN value1 THEN statement1;&lt;br&gt;  WHEN value2 THEN statement2;&lt;br&gt;  ELSE statement3;&lt;br&gt;END CASE;&lt;br&gt;-- Searched CASE:&lt;br&gt;CASE&lt;br&gt;  WHEN condition1 THEN statement1;&lt;br&gt;  WHEN condition2 THEN statement2;&lt;br&gt;END CASE;</code> For multiple value-based conditions, cleaner and more readable than multiple IF statements Simple LOOP Basic loop structure that repeats until an EXIT condition is met <code>sql&lt;br&gt;LOOP&lt;br&gt;  statements;&lt;br&gt;  EXIT WHEN condition;&lt;br&gt;END LOOP;</code> When you need at least one execution, or have complex exit conditions in the middle of loop WHILE LOOP Loop that continues as long as a condition remains true, condition checked before each iteration <code>sql&lt;br&gt;WHILE condition LOOP&lt;br&gt;  statements;&lt;br&gt;END LOOP;</code> When condition needs to be checked before each iteration, may execute zero times FOR LOOP (Numeric) Loop that iterates a predetermined number of times using a counter variable <code>sql&lt;br&gt;FOR i IN 1..10 LOOP&lt;br&gt;  statements;&lt;br&gt;END LOOP;&lt;br&gt;-- Reverse:&lt;br&gt;FOR i IN REVERSE 1..10 LOOP&lt;br&gt;  statements;&lt;br&gt;END LOOP;</code> For known number of iterations, automatic counter management FOR LOOP (Cursor) Simplified loop for processing cursor data, automatically handles cursor operations <code>sql&lt;br&gt;FOR rec IN cursor_name LOOP&lt;br&gt;  -- rec.column_name&lt;br&gt;  statements;&lt;br&gt;END LOOP;&lt;br&gt;-- Implicit cursor:&lt;br&gt;FOR rec IN (SELECT * FROM table) LOOP&lt;br&gt;  statements;&lt;br&gt;END LOOP;</code> To process all rows from a cursor automatically without explicit open/fetch/close GOTO Statement that transfers control unconditionally to a labeled statement <code>sql&lt;br&gt;&lt;&lt;label_name&gt;&gt;&lt;br&gt;statements;&lt;br&gt;GOTO label_name;</code> Generally discouraged, only for error handling or breaking out of nested loops"},{"location":"Interview/3.plsql/#4-cursors","title":"4. CURSORS","text":"Cursor Type Definition Syntax When to Use Cursor Pointer to a context area that holds the result set of a SQL query, allows row-by-row processing Memory area for SQL query results When processing query results row by row instead of all at once Implicit Cursor Automatically created cursor for SQL DML statements, Oracle manages it automatically <code>sql&lt;br&gt;SELECT column INTO variable FROM table&lt;br&gt;WHERE condition;&lt;br&gt;-- Cursor attributes:&lt;br&gt;SQL%FOUND, SQL%NOTFOUND&lt;br&gt;SQL%ROWCOUNT, SQL%ISOPEN</code> For single-row SELECT INTO statements, DML operations (INSERT/UPDATE/DELETE) Explicit Cursor User-defined cursor that must be declared, opened, fetched from, and closed manually <code>sql&lt;br&gt;DECLARE&lt;br&gt;  CURSOR c_emp IS &lt;br&gt;    SELECT * FROM employees WHERE dept_id = 10;&lt;br&gt;  v_emp employees%ROWTYPE;&lt;br&gt;BEGIN&lt;br&gt;  OPEN c_emp;&lt;br&gt;  LOOP&lt;br&gt;    FETCH c_emp INTO v_emp;&lt;br&gt;    EXIT WHEN c_emp%NOTFOUND;&lt;br&gt;    -- process v_emp&lt;br&gt;  END LOOP;&lt;br&gt;  CLOSE c_emp;&lt;br&gt;END;</code> When processing multiple rows, need cursor attributes, complex result sets, or want control over cursor lifecycle Cursor with Parameters Cursor that accepts input parameters to make it reusable with different values <code>sql&lt;br&gt;CURSOR c_emp(p_dept_id NUMBER, p_salary NUMBER) IS&lt;br&gt;  SELECT * FROM employees&lt;br&gt;  WHERE department_id = p_dept_id&lt;br&gt;  AND salary &gt; p_salary;&lt;br&gt;-- Usage:&lt;br&gt;OPEN c_emp(10, 5000);</code> To make cursors reusable with different filter values, improving code modularity REF CURSOR Cursor variable that can point to different result sets at runtime, providing flexibility <code>sql&lt;br&gt;TYPE ref_cursor IS REF CURSOR;&lt;br&gt;v_cursor ref_cursor;&lt;br&gt;-- Strongly typed:&lt;br&gt;TYPE emp_cursor IS REF CURSOR RETURN employees%ROWTYPE;&lt;br&gt;v_emp_cursor emp_cursor;</code> For dynamic cursors, returning cursors from functions, or when cursor structure determined at runtime Cursor Attributes Properties that provide information about cursor status and processing results <code>sql&lt;br&gt;cursor_name%FOUND    -- TRUE if last fetch returned a row&lt;br&gt;cursor_name%NOTFOUND -- TRUE if last fetch found no row&lt;br&gt;cursor_name%ROWCOUNT -- Number of rows fetched so far&lt;br&gt;cursor_name%ISOPEN   -- TRUE if cursor is open</code> To check cursor status, control loop processing, and get information about fetch operations"},{"location":"Interview/3.plsql/#5-exception-handling","title":"5. EXCEPTION HANDLING","text":"Exception Type Definition Syntax When to Use Exception Runtime error that occurs during program execution, can be predefined, user-defined, or pragma exceptions Abnormal condition that disrupts normal program flow To handle errors gracefully instead of program termination Exception Handling Mechanism to catch and handle errors using EXCEPTION block with WHEN clauses <code>sql&lt;br&gt;BEGIN&lt;br&gt;  statements;&lt;br&gt;EXCEPTION&lt;br&gt;  WHEN exception_name THEN&lt;br&gt;    handle_exception;&lt;br&gt;  WHEN OTHERS THEN&lt;br&gt;    handle_any_exception;&lt;br&gt;END;</code> To handle predictable errors gracefully and provide meaningful error messages Predefined Exceptions Built-in exceptions provided by Oracle for common error conditions <code>sql&lt;br&gt;EXCEPTION&lt;br&gt;  WHEN NO_DATA_FOUND THEN&lt;br&gt;    -- SELECT INTO found no rows&lt;br&gt;  WHEN TOO_MANY_ROWS THEN&lt;br&gt;    -- SELECT INTO found multiple rows&lt;br&gt;  WHEN ZERO_DIVIDE THEN&lt;br&gt;    -- Division by zero attempted&lt;br&gt;  WHEN VALUE_ERROR THEN&lt;br&gt;    -- Conversion/constraint error&lt;br&gt;  WHEN DUP_VAL_ON_INDEX THEN&lt;br&gt;    -- Unique constraint violation&lt;br&gt;END;</code> For handling common Oracle database errors with meaningful names User-Defined Exception Custom exceptions declared by programmer for business logic errors <code>sql&lt;br&gt;DECLARE&lt;br&gt;  invalid_salary EXCEPTION;&lt;br&gt;  negative_balance EXCEPTION;&lt;br&gt;BEGIN&lt;br&gt;  IF salary &lt; 0 THEN&lt;br&gt;    RAISE invalid_salary;&lt;br&gt;  END IF;&lt;br&gt;EXCEPTION&lt;br&gt;  WHEN invalid_salary THEN&lt;br&gt;    DBMS_OUTPUT.PUT_LINE('Salary cannot be negative');&lt;br&gt;END;</code> For business rule violations, custom validation errors, or application-specific conditions RAISE Statement Explicitly raises an exception in the program, can re-raise current exception <code>sql&lt;br&gt;RAISE exception_name;&lt;br&gt;RAISE; -- re-raises current exception</code> To trigger exceptions based on business logic or to propagate exceptions to calling programs PRAGMA EXCEPTION_INIT Associates a user-defined exception name with a specific Oracle error number <code>sql&lt;br&gt;DECLARE&lt;br&gt;  duplicate_value EXCEPTION;&lt;br&gt;  PRAGMA EXCEPTION_INIT(duplicate_value, -1);&lt;br&gt;BEGIN&lt;br&gt;  -- statements that might cause ORA-00001&lt;br&gt;EXCEPTION&lt;br&gt;  WHEN duplicate_value THEN&lt;br&gt;    DBMS_OUTPUT.PUT_LINE('Record already exists');&lt;br&gt;END;</code> To give meaningful names to Oracle error numbers for better code readability"},{"location":"Interview/3.plsql/#6-subprograms","title":"6. SUBPROGRAMS","text":"Type Definition Syntax When to Use Procedure Named PL/SQL block that performs specific tasks, can accept parameters but doesn't return a value <code>sql&lt;br&gt;CREATE OR REPLACE PROCEDURE proc_name(&lt;br&gt;  p_param1 IN VARCHAR2,&lt;br&gt;  p_param2 OUT NUMBER,&lt;br&gt;  p_param3 IN OUT DATE&lt;br&gt;) IS&lt;br&gt;  -- local declarations&lt;br&gt;BEGIN&lt;br&gt;  -- procedure body&lt;br&gt;  p_param2 := 100; -- setting OUT parameter&lt;br&gt;END proc_name;&lt;br&gt;-- Calling:&lt;br&gt;EXECUTE proc_name('value', v_result, v_date);</code> For reusable code that performs actions, may return multiple values through OUT parameters Function Named PL/SQL block that performs calculations and returns a single value through RETURN statement <code>sql&lt;br&gt;CREATE OR REPLACE FUNCTION func_name(&lt;br&gt;  p_param1 VARCHAR2,&lt;br&gt;  p_param2 NUMBER DEFAULT 0&lt;br&gt;) RETURN NUMBER IS&lt;br&gt;  v_result NUMBER;&lt;br&gt;BEGIN&lt;br&gt;  -- function body&lt;br&gt;  v_result := LENGTH(p_param1) + p_param2;&lt;br&gt;  RETURN v_result;&lt;br&gt;END func_name;&lt;br&gt;-- Calling:&lt;br&gt;v_length := func_name('Hello', 10);</code> For reusable code that calculates and returns a single value, can be used in SQL statements Parameters Variables used to pass values into or out of procedures and functions <code>sql&lt;br&gt;-- IN: passes value to subprogram (default)&lt;br&gt;-- OUT: returns value from subprogram&lt;br&gt;-- IN OUT: passes value in and returns modified value&lt;br&gt;PROCEDURE example(&lt;br&gt;  p_input IN VARCHAR2,        -- input only&lt;br&gt;  p_output OUT NUMBER,        -- output only&lt;br&gt;  p_both IN OUT DATE          -- input and output&lt;br&gt;)</code> To make subprograms flexible and reusable with different data values Local Subprogram Procedure or function defined within another PL/SQL block, only accessible within that block <code>sql&lt;br&gt;DECLARE&lt;br&gt;  PROCEDURE local_proc(p_val NUMBER) IS&lt;br&gt;  BEGIN&lt;br&gt;    DBMS_OUTPUT.PUT_LINE('Value: ' || p_val);&lt;br&gt;  END;&lt;br&gt;  &lt;br&gt;  FUNCTION local_func RETURN NUMBER IS&lt;br&gt;  BEGIN&lt;br&gt;    RETURN 42;&lt;br&gt;  END;&lt;br&gt;BEGIN&lt;br&gt;  local_proc(local_func);&lt;br&gt;END;</code> For code reuse within a single block only, when functionality doesn't need global access Overloading Feature allowing multiple subprograms with same name but different parameter signatures <code>sql&lt;br&gt;CREATE OR REPLACE PACKAGE pkg IS&lt;br&gt;  PROCEDURE process_data(p_id NUMBER);&lt;br&gt;  PROCEDURE process_data(p_name VARCHAR2);&lt;br&gt;  PROCEDURE process_data(p_id NUMBER, p_name VARCHAR2);&lt;br&gt;END pkg;</code> To provide different ways to call the same logical operation with different parameter types Forward Declaration Declaration of a subprogram before its actual definition, used to resolve mutual dependencies <code>sql&lt;br&gt;DECLARE&lt;br&gt;  -- Forward declaration&lt;br&gt;  PROCEDURE proc_b(p_val NUMBER);&lt;br&gt;  &lt;br&gt;  PROCEDURE proc_a(p_val NUMBER) IS&lt;br&gt;  BEGIN&lt;br&gt;    IF p_val &gt; 0 THEN&lt;br&gt;      proc_b(p_val - 1);&lt;br&gt;    END IF;&lt;br&gt;  END;&lt;br&gt;  &lt;br&gt;  -- Actual definition&lt;br&gt;  PROCEDURE proc_b(p_val NUMBER) IS&lt;br&gt;  BEGIN&lt;br&gt;    proc_a(p_val);&lt;br&gt;  END;&lt;br&gt;BEGIN&lt;br&gt;  proc_a(5);&lt;br&gt;END;</code> When two subprograms need to call each other (mutual recursion)"},{"location":"Interview/3.plsql/#7-packages","title":"7. PACKAGES","text":"Component Definition Syntax When to Use Package Container that groups related procedures, functions, variables, and other constructs together Modular programming unit that encapsulates related functionality To organize code logically, provide data encapsulation, and improve performance Package Specification Public interface of a package that declares what can be accessed from outside the package <code>sql&lt;br&gt;CREATE OR REPLACE PACKAGE pkg_employee IS&lt;br&gt;  -- Public constants&lt;br&gt;  c_max_salary CONSTANT NUMBER := 100000;&lt;br&gt;  &lt;br&gt;  -- Public variables&lt;br&gt;  g_total_employees NUMBER;&lt;br&gt;  &lt;br&gt;  -- Public procedures and functions&lt;br&gt;  PROCEDURE hire_employee(p_name VARCHAR2);&lt;br&gt;  FUNCTION get_employee_count RETURN NUMBER;&lt;br&gt;  &lt;br&gt;  -- Public exception&lt;br&gt;  invalid_employee EXCEPTION;&lt;br&gt;END pkg_employee;</code> To define public interface, group related functionality, hide implementation details Package Body Implementation of the package containing actual code for procedures and functions <code>sql&lt;br&gt;CREATE OR REPLACE PACKAGE BODY pkg_employee IS&lt;br&gt;  -- Private variables&lt;br&gt;  g_last_hire_date DATE;&lt;br&gt;  &lt;br&gt;  -- Private procedure&lt;br&gt;  PROCEDURE log_action(p_action VARCHAR2) IS&lt;br&gt;  BEGIN&lt;br&gt;    INSERT INTO audit_log VALUES (p_action, SYSDATE);&lt;br&gt;  END;&lt;br&gt;  &lt;br&gt;  -- Public procedure implementation&lt;br&gt;  PROCEDURE hire_employee(p_name VARCHAR2) IS&lt;br&gt;  BEGIN&lt;br&gt;    INSERT INTO employees (name) VALUES (p_name);&lt;br&gt;    g_total_employees := g_total_employees + 1;&lt;br&gt;    log_action('HIRED: ' || p_name);&lt;br&gt;  END;&lt;br&gt;  &lt;br&gt;  -- Public function implementation&lt;br&gt;  FUNCTION get_employee_count RETURN NUMBER IS&lt;br&gt;  BEGIN&lt;br&gt;    RETURN g_total_employees;&lt;br&gt;  END;&lt;br&gt;BEGIN&lt;br&gt;  -- Package initialization&lt;br&gt;  SELECT COUNT(*) INTO g_total_employees FROM employees;&lt;br&gt;END pkg_employee;</code> To implement the functionality declared in package specification"},{"location":"Interview/3.plsql/#8-triggers","title":"8. TRIGGERS","text":"Type Definition Syntax When to Use Trigger Special PL/SQL block that automatically executes in response to specific database events Stored program that runs automatically when certain events occur For automatic data validation, auditing, logging, or enforcing business rules DML Trigger Trigger that fires in response to DML operations (INSERT, UPDATE, DELETE) on a table <code>sql&lt;br&gt;CREATE OR REPLACE TRIGGER trg_emp_audit&lt;br&gt;BEFORE UPDATE ON employees&lt;br&gt;FOR EACH ROW&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO emp_audit (&lt;br&gt;    emp_id, old_salary, new_salary, change_date&lt;br&gt;  ) VALUES (&lt;br&gt;    :NEW.employee_id, :OLD.salary, :NEW.salary, SYSDATE&lt;br&gt;  );&lt;br&gt;END;&lt;br&gt;-- Timing: BEFORE, AFTER, INSTEAD OF&lt;br&gt;-- Events: INSERT, UPDATE, DELETE&lt;br&gt;-- Level: FOR EACH ROW, statement level</code> For auditing data changes, automatic column population, data validation before changes DDL Trigger Trigger that fires in response to DDL operations (CREATE, ALTER, DROP) on database objects <code>sql&lt;br&gt;CREATE OR REPLACE TRIGGER trg_ddl_audit&lt;br&gt;AFTER CREATE OR ALTER OR DROP&lt;br&gt;ON SCHEMA&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO ddl_audit (&lt;br&gt;    object_name, object_type, operation, change_date&lt;br&gt;  ) VALUES (&lt;br&gt;    ora_dict_obj_name, ora_dict_obj_type,&lt;br&gt;    ora_sysevent, SYSDATE&lt;br&gt;  );&lt;br&gt;END;</code> For tracking schema changes, preventing unauthorized DDL operations System Trigger Trigger that fires in response to database system events like startup, shutdown, logon <code>sql&lt;br&gt;CREATE OR REPLACE TRIGGER trg_logon_audit&lt;br&gt;AFTER LOGON ON SCHEMA&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO user_sessions (&lt;br&gt;    username, logon_time, session_id&lt;br&gt;  ) VALUES (&lt;br&gt;    USER, SYSDATE, USERENV('SESSIONID')&lt;br&gt;  );&lt;br&gt;END;</code> For user session tracking, security auditing, system monitoring OLD and NEW Correlation names used in DML triggers to reference old and new values of columns <code>sql&lt;br&gt;-- In row-level DML triggers:&lt;br&gt;:OLD.column_name  -- value before change&lt;br&gt;:NEW.column_name  -- value after change&lt;br&gt;-- Example:&lt;br&gt;IF :NEW.salary &gt; :OLD.salary * 1.5 THEN&lt;br&gt;  RAISE_APPLICATION_ERROR(-20001, 'Salary increase too large');&lt;br&gt;END IF;</code> To compare old and new values during data modifications Mutating Table Table that is being modified by a DML statement when a trigger tries to query or modify it Error condition that prevents triggers from querying the table being modified Understanding why certain operations fail in triggers, designing workarounds"},{"location":"Interview/3.plsql/#9-collections","title":"9. COLLECTIONS","text":"Type Definition Syntax When to Use Collection Ordered group of elements of the same datatype, types include VARRAY, Nested Table, and Associative Array Data structure for storing multiple values of same type When working with sets of related data, bulk operations, or arrays VARRAY Variable-size array with a maximum limit on the number of elements, stored in database <code>sql&lt;br&gt;-- Declaration:&lt;br&gt;TYPE name_array IS VARRAY(10) OF VARCHAR2(50);&lt;br&gt;v_names name_array;&lt;br&gt;-- Usage:&lt;br&gt;v_names := name_array('John', 'Jane', 'Bob');&lt;br&gt;v_names.EXTEND; -- add space&lt;br&gt;v_names(4) := 'Alice';&lt;br&gt;-- Methods: COUNT, LIMIT, EXISTS, EXTEND, TRIM</code> For small, fixed-maximum collections that need to be stored in database tables Nested Table Unbounded, ordered collection of elements that can be stored in database tables <code>sql&lt;br&gt;-- Declaration:&lt;br&gt;TYPE number_table IS TABLE OF NUMBER;&lt;br&gt;v_numbers number_table;&lt;br&gt;-- Usage:&lt;br&gt;v_numbers := number_table(1, 2, 3, 4, 5);&lt;br&gt;v_numbers.EXTEND;&lt;br&gt;v_numbers(6) := 10;&lt;br&gt;-- Methods: COUNT, EXISTS, EXTEND, TRIM, DELETE</code> For large collections with no size limit, when you need to store in database Associative Array Index-by table that uses string or integer indexes to access elements <code>sql&lt;br&gt;-- Declaration:&lt;br&gt;TYPE emp_array IS TABLE OF employees%ROWTYPE&lt;br&gt;  INDEX BY PLS_INTEGER;&lt;br&gt;TYPE salary_array IS TABLE OF NUMBER&lt;br&gt;  INDEX BY VARCHAR2(50);&lt;br&gt;-- Usage:&lt;br&gt;v_emps emp_array;&lt;br&gt;v_salaries salary_array;&lt;br&gt;v_emps(1) := employee_record;&lt;br&gt;v_salaries('SMITH') := 5000;</code> For in-memory processing, when you need key-value pairs, or sparse arrays"},{"location":"Interview/3.plsql/#10-bulk-operations","title":"10. BULK OPERATIONS","text":"Operation Definition Syntax When to Use BULK COLLECT Feature that allows fetching multiple rows at once from cursor into collection, improving performance <code>sql&lt;br&gt;DECLARE&lt;br&gt;  TYPE name_array IS TABLE OF employees.first_name%TYPE;&lt;br&gt;  v_names name_array;&lt;br&gt;  CURSOR c_emp IS SELECT first_name FROM employees;&lt;br&gt;BEGIN&lt;br&gt;  -- Fetch all rows at once&lt;br&gt;  OPEN c_emp;&lt;br&gt;  FETCH c_emp BULK COLLECT INTO v_names;&lt;br&gt;  CLOSE c_emp;&lt;br&gt;  -- Process collection&lt;br&gt;  FOR i IN 1..v_names.COUNT LOOP&lt;br&gt;    DBMS_OUTPUT.PUT_LINE(v_names(i));&lt;br&gt;  END LOOP;&lt;br&gt;END;&lt;br&gt;-- With LIMIT:&lt;br&gt;FETCH cursor_name BULK COLLECT INTO collection LIMIT 1000;</code> When processing large result sets to reduce context switching between PL/SQL and SQL engines FORALL Statement that performs bulk DML operations on collections, processing multiple rows efficiently <code>sql&lt;br&gt;DECLARE&lt;br&gt;  TYPE id_array IS TABLE OF employees.employee_id%TYPE;&lt;br&gt;  v_ids id_array;&lt;br&gt;BEGIN&lt;br&gt;  -- Populate collection&lt;br&gt;  SELECT employee_id BULK COLLECT INTO v_ids&lt;br&gt;  FROM employees WHERE department_id = 10;&lt;br&gt;  &lt;br&gt;  -- Bulk delete&lt;br&gt;  FORALL i IN 1..v_ids.COUNT&lt;br&gt;    DELETE FROM employees WHERE employee_id = v_ids(i);&lt;br&gt;    &lt;br&gt;  -- Bulk insert&lt;br&gt;  FORALL i IN v_new_emps.FIRST..v_new_emps.LAST&lt;br&gt;    INSERT INTO employees VALUES v_new_emps(i);&lt;br&gt;END;</code> For high-performance DML operations on collections, significantly faster than row-by-row processing"},{"location":"Interview/3.plsql/#11-transaction-control","title":"11. TRANSACTION CONTROL","text":"Statement Definition Syntax When to Use COMMIT Makes all changes in the current transaction permanent and releases locks <code>sql&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO table1 VALUES (...);&lt;br&gt;  UPDATE table2 SET ...;&lt;br&gt;  COMMIT; -- makes changes permanent&lt;br&gt;END;</code> To permanently save changes when you're confident all operations succeeded ROLLBACK Undoes all changes made in current transaction and releases locks <code>sql&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO table1 VALUES (...);&lt;br&gt;  IF error_condition THEN&lt;br&gt;    ROLLBACK; -- undo all changes&lt;br&gt;  ELSE&lt;br&gt;    COMMIT;&lt;br&gt;  END IF;&lt;br&gt;END;</code> To undo changes when errors occur or conditions aren't met SAVEPOINT Named point in transaction to which you can roll back without rolling back entire transaction <code>sql&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO table1 VALUES (...);&lt;br&gt;  SAVEPOINT sp1;&lt;br&gt;  UPDATE table2 SET ...;&lt;br&gt;  IF error_condition THEN&lt;br&gt;    ROLLBACK TO sp1; -- undo only UPDATE&lt;br&gt;  END IF;&lt;br&gt;  COMMIT;&lt;br&gt;END;</code> For partial rollbacks in complex transactions with multiple steps PRAGMA AUTONOMOUS_TRANSACTION Directive that makes a subprogram execute in its own independent transaction <code>sql&lt;br&gt;CREATE OR REPLACE PROCEDURE log_error(&lt;br&gt;  p_error VARCHAR2&lt;br&gt;) IS&lt;br&gt;PRAGMA AUTONOMOUS_TRANSACTION;&lt;br&gt;BEGIN&lt;br&gt;  INSERT INTO error_log VALUES (p_error, SYSDATE);&lt;br&gt;  COMMIT; -- independent of calling transaction&lt;br&gt;END;</code> For logging that should persist even if main transaction rolls back"},{"location":"Interview/3.plsql/#12-dynamic-sql","title":"12. DYNAMIC SQL","text":"Feature Definition Syntax When to Use EXECUTE IMMEDIATE Executes dynamically constructed SQL statements at runtime <code>sql&lt;br&gt;DECLARE&lt;br&gt;  v_sql VARCHAR2(1000);&lt;br&gt;  v_table_name VARCHAR2(30) := 'employees';&lt;br&gt;  v_count NUMBER;&lt;br&gt;BEGIN&lt;br&gt;  -- Dynamic query&lt;br&gt;  v_sql := 'SELECT COUNT(*) FROM ' || v_table_name;&lt;br&gt;  EXECUTE IMMEDIATE v_sql INTO v_count;&lt;br&gt;  &lt;br&gt;  -- Dynamic DML with parameters&lt;br&gt;  v_sql := 'UPDATE ' || v_table_name || &lt;br&gt;           ' SET salary = salary * :1 WHERE dept_id = :2';&lt;br&gt;  EXECUTE IMMEDIATE v_sql USING 1.1, 10;&lt;br&gt;END;</code> When SQL statements need to be constructed at runtime based on conditions or user input"},{"location":"Interview/3.plsql/#13-performance-features","title":"13. PERFORMANCE FEATURES","text":"Feature Definition Syntax When to Use Pipelined Function Function that returns rows as they are produced rather than building entire result set first <code>sql&lt;br&gt;CREATE OR REPLACE FUNCTION get_employees&lt;br&gt;RETURN sys.odcinumberlist PIPELINED IS&lt;br&gt;BEGIN&lt;br&gt;  FOR rec IN (SELECT employee_id FROM employees) LOOP&lt;br&gt;    PIPE ROW(rec.employee_id);&lt;br&gt;  END LOOP;&lt;br&gt;  RETURN;&lt;br&gt;END;&lt;br&gt;-- Usage in SQL:&lt;br&gt;SELECT * FROM TABLE(get_employees());</code> For memory-efficient processing of large result sets, especially in ETL operations Deterministic Function Function that always returns the same result for the same input parameters <code>sql&lt;br&gt;CREATE OR REPLACE FUNCTION calculate_tax(&lt;br&gt;  p_salary NUMBER&lt;br&gt;) RETURN NUMBER DETERMINISTIC IS&lt;br&gt;BEGIN&lt;br&gt;  RETURN p_salary * 0.15;&lt;br&gt;END;&lt;br&gt;-- Oracle can cache results for same inputs</code> When function results can be cached for performance, pure mathematical calculations Parallel Enable Hint that allows a function to be executed in parallel during query processing <code>sql&lt;br&gt;CREATE OR REPLACE FUNCTION process_data(&lt;br&gt;  p_value NUMBER&lt;br&gt;) RETURN NUMBER&lt;br&gt;PARALLEL_ENABLE IS&lt;br&gt;BEGIN&lt;br&gt;  RETURN p_value * 2;&lt;br&gt;END;</code> For functions used in SELECT statements that can benefit from parallel execution"}]}