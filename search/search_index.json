{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Interview/1.Introduction/","title":"Introduction","text":"<p>Hi, I am __, working as a PL/SQL Developer with around 4 years of experience in SQL and PL/SQL development using Oracle 12c/19c. I have worked on development, enhancement, and support projects in domains like Banking, Retail, and Sales.  </p> <p>My expertise includes: - Writing complex SQL queries, stored procedures, functions, packages, and triggers. - SQL performance tuning, exception handling, bulk operations, and data loading using SQL*Loader. - Data modeling (Star and Snowflake schema). - BI reporting tools like QlikView and BI Publisher. - Working in Agile methodology.  </p> <p>I am also involved in client interactions for requirement gathering, effort estimation, and providing regular updates.  </p>"},{"location":"Interview/1.Introduction/#day-to-day-activities-story-style","title":"Day-to-Day Activities (Story Style)","text":"<p>In my project, my day usually starts with a stand-up meeting where I update the team on my progress and plan the day\u2019s work. After that, I check tickets and production logs to see if any jobs or procedures have failed.  </p> <p>Most of my time goes into developing and enhancing PL/SQL objects like procedures, functions, packages, and triggers to meet business requirements. I also work on data loading using SQL*Loader and design database objects such as tables and views when needed.  </p> <p>Alongside development, I spend time testing and debugging the code, optimizing queries for better performance, and fixing any production issues reported by users. I also interact with business analysts and clients to clarify requirements and provide effort estimates.  </p> <p>By the end of the day, I update the task tracker, document the changes, and share my status with the team.  </p>"},{"location":"Interview/2.sql/","title":"sql_interview","text":"<p>markdown</p>"},{"location":"Interview/2.sql/#oracle-sql-interview-questions-answers","title":"Oracle SQL Interview Questions &amp; Answers","text":""},{"location":"Interview/2.sql/#1-basic-sql-questions","title":"1. Basic SQL Questions","text":""},{"location":"Interview/2.sql/#q1-difference-between-delete-truncate-and-drop","title":"Q1. Difference between DELETE, TRUNCATE, and DROP","text":"<ul> <li>DELETE: DML, can delete all or specific rows, slower, rollback possible.  </li> <li>TRUNCATE: DDL, removes all rows at once, faster, rollback not possible.  </li> <li>DROP: Removes the table definition and all data permanently.  </li> </ul>"},{"location":"Interview/2.sql/#q2-difference-between-char-and-varchar2","title":"Q2. Difference between CHAR and VARCHAR2","text":"<ul> <li>CHAR(n): Fixed length, always allocates <code>n</code> characters (pads with spaces).  </li> <li>VARCHAR2(n): Variable length, stores only actual characters.  </li> </ul>"},{"location":"Interview/2.sql/#q3-difference-between-date-and-timestamp","title":"Q3. Difference between DATE and TIMESTAMP","text":"<ul> <li>DATE: Stores date and time (to the second).  </li> <li>TIMESTAMP: Stores date, time, and fractional seconds (up to microseconds).  </li> </ul>"},{"location":"Interview/2.sql/#q4-difference-between-substr-and-instr","title":"Q4. Difference between SUBSTR and INSTR","text":"<ul> <li>SUBSTR: Extracts part of a string. <pre><code>SELECT SUBSTR('welcome',1,3) FROM dual; -- wel\n</code></pre></li> <li>INSTR: Finds position of a character or substring. <pre><code>SELECT INSTR('welcome','e',1,1) FROM dual; -- 2\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#q5-what-are-constraints-in-oracle-sql","title":"Q5. What are constraints in Oracle SQL?","text":"<ul> <li>NOT NULL \u2013 Column must have a value.  </li> <li>UNIQUE \u2013 All values must be unique.  </li> <li>PRIMARY KEY \u2013 Combination of NOT NULL + UNIQUE.  </li> <li>FOREIGN KEY \u2013 Enforces referential integrity.  </li> <li>CHECK \u2013 Ensures condition on column values.  </li> <li>DEFAULT \u2013 Assigns default value if not provided.  </li> </ul>"},{"location":"Interview/2.sql/#q6-difference-between-view-and-materialized-view","title":"Q6. Difference between VIEW and MATERIALIZED VIEW","text":"<ul> <li>VIEW: Logical representation of a query, always shows live data.  </li> <li>MATERIALIZED VIEW: Stores data physically, can be refreshed manually or on schedule.  </li> </ul>"},{"location":"Interview/2.sql/#q7-union-vs-union-all","title":"Q7. UNION vs UNION ALL","text":"<ul> <li>UNION: Removes duplicates, sorts results.  </li> <li>UNION ALL: Keeps duplicates, faster.  </li> </ul>"},{"location":"Interview/2.sql/#q8-how-to-delete-duplicate-records","title":"Q8. How to delete duplicate records?","text":"<pre><code>DELETE FROM emp e1\nWHERE ROWID &gt; (\n  SELECT MIN(ROWID)\n  FROM emp e2\n  WHERE e2.emp_id = e1.emp_id\n);\n\n-- To display duplicates\nSELECT emp_id, COUNT(*)\nFROM emp\nGROUP BY emp_id\nHAVING COUNT(*) &gt; 1;\n</code></pre>"},{"location":"Interview/2.sql/#q9-rank-vs-dense_rank","title":"Q9. RANK vs DENSE_RANK","text":"<ul> <li>RANK: Assigns rank, skips numbers if duplicates exist.  </li> <li>DENSE_RANK: Assigns rank without gaps, consecutive numbers.  </li> </ul>"},{"location":"Interview/2.sql/#q10-right-join-vs-left-join","title":"Q10. Right Join vs Left Join","text":"<ul> <li>LEFT JOIN: All rows from left table + matched rows from right.  </li> <li>RIGHT JOIN: All rows from right table + matched rows from left.  </li> </ul>"},{"location":"Interview/2.sql/#q11-why-do-we-use-joins-types","title":"Q11. Why do we use Joins? Types?","text":"<p>We use joins to combine rows from multiple tables based on related columns.  </p> <p>Types: - Equi join - Non-Equi join - Cross join - Inner join - Left Outer join - Right Outer join - Full Outer join - Self join  </p>"},{"location":"Interview/2.sql/#2-intermediate-sql-questions","title":"2. Intermediate SQL Questions","text":""},{"location":"Interview/2.sql/#q12-what-are-indexes-types-of-indexes-in-oracle","title":"Q12. What are indexes? Types of indexes in Oracle?","text":"<ul> <li>Indexes speed up query performance. Types:  </li> <li>B-tree (default, balanced structure).  </li> <li>Bitmap (good for low-cardinality columns).  </li> <li>Function-based index.  </li> <li>Composite index (multiple columns).  </li> <li>Unique and Non-Unique indexes.  </li> </ul>"},{"location":"Interview/2.sql/#q13-what-are-aggregate-and-analytic-functions","title":"Q13. What are aggregate and analytic functions?","text":"<ul> <li>Aggregate functions: Perform calculations on groups. (SUM, AVG, COUNT, MAX, MIN).  </li> <li>Analytic functions: Work on sets of rows and return values per row. <pre><code>SELECT emp_id, salary,\n       RANK() OVER (ORDER BY salary DESC) AS salary_rank\nFROM employees;\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#q14-what-are-subqueries-and-correlated-subqueries","title":"Q14. What are subqueries and correlated subqueries?","text":"<ul> <li>Subquery: A query inside another query, executes once. <pre><code>SELECT name FROM employees\nWHERE dept_id = (SELECT dept_id FROM departments WHERE dept_name = 'IT');\n</code></pre></li> <li>Correlated Subquery: Executes once for each row of the outer query. <pre><code>SELECT name FROM employees e\nWHERE salary &gt; (SELECT AVG(salary) FROM employees WHERE dept_id = e.dept_id);\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#3-advanced-sql-questions","title":"3. Advanced SQL Questions","text":""},{"location":"Interview/2.sql/#q15-what-is-rownum-vs-row_number","title":"Q15. What is ROWNUM vs ROW_NUMBER()?","text":"<ul> <li>ROWNUM: Pseudocolumn, assigned before ORDER BY.  </li> <li>ROW_NUMBER(): Analytic function, assigns number after ORDER BY.  </li> </ul>"},{"location":"Interview/2.sql/#q16-what-is-the-difference-between-exists-and-in","title":"Q16. What is the difference between EXISTS and IN?","text":"<ul> <li>IN: Compares value with a list or subquery result.  </li> <li>EXISTS: Returns TRUE if subquery returns at least one row, often faster with correlated queries. <pre><code>-- Using IN\nSELECT name FROM employees WHERE dept_id IN (SELECT dept_id FROM departments);\n\n-- Using EXISTS\nSELECT name FROM employees e\nWHERE EXISTS (SELECT 1 FROM departments d WHERE d.dept_id = e.dept_id);\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#q17-how-to-find-the-2nd-highest-salary","title":"Q17. How to find the 2nd highest salary?","text":"<pre><code>-- Using Subquery\nSELECT MAX(salary) FROM employees\nWHERE salary &lt; (SELECT MAX(salary) FROM employees);\n\n-- Using Analytic Function\nSELECT * FROM (\n    SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS rnk\n    FROM employees\n) WHERE rnk = 2;\n</code></pre>"},{"location":"Interview/2.sql/#q18-difference-between-delete-with-where-and-trigger-with-cascade-delete","title":"Q18. Difference between DELETE with WHERE and Trigger with Cascade Delete","text":"<ul> <li>DELETE with WHERE: Deletes only specified rows.  </li> <li>Cascade Delete (via Trigger/Constraint): Automatically deletes child rows when parent row is deleted.  </li> </ul>"},{"location":"Interview/2.sql/#q19-how-to-improve-sql-performance-tuning","title":"Q19. How to improve SQL performance? (Tuning)","text":"<ul> <li>Use <code>EXPLAIN PLAN</code> or <code>DBMS_XPLAN</code> to check execution.  </li> <li>Create proper indexes.  </li> <li>Avoid <code>SELECT *</code>, fetch only needed columns.  </li> <li>Use bind variables.  </li> <li>Partition large tables.  </li> <li>Rewrite queries for efficiency.  </li> <li>Use bulk operations for large datasets.  </li> </ul>"},{"location":"Interview/2.sql/#q20-what-is-a-cte-with-clause","title":"Q20. What is a CTE (WITH clause)?","text":"<p>A Common Table Expression improves readability and reusability. <pre><code>WITH dept_avg AS (\n   SELECT dept_id, AVG(salary) AS avg_sal\n   FROM employees\n   GROUP BY dept_id\n)\nSELECT e.name, e.salary, d.avg_sal\nFROM employees e\nJOIN dept_avg d ON e.dept_id = d.dept_id;\n</code></pre></p>"},{"location":"Interview/2.sql/#q21-explain-merge-statement","title":"Q21. Explain MERGE statement","text":"<p>Used for UPSERT (Insert or Update in one statement). <pre><code>MERGE INTO employees e\nUSING new_employees n\nON (e.emp_id = n.emp_id)\nWHEN MATCHED THEN\n   UPDATE SET e.salary = n.salary\nWHEN NOT MATCHED THEN\n   INSERT (emp_id, name, salary) VALUES (n.emp_id, n.name, n.salary);\n</code></pre></p>"},{"location":"Interview/2.sql/#q22-difference-between-primary-key-and-unique","title":"Q22. Difference between PRIMARY KEY and UNIQUE","text":"<ul> <li>PRIMARY KEY: Only one per table, enforces uniqueness + NOT NULL.  </li> <li>UNIQUE: Allows one NULL, multiple unique constraints allowed.  </li> </ul>"},{"location":"Interview/2.sql/#q23-what-are-global-temporary-tables-gtt","title":"Q23. What are Global Temporary Tables (GTT)?","text":"<ul> <li>Data is session/transaction-specific, structure is permanent. <pre><code>CREATE GLOBAL TEMPORARY TABLE temp_emp (\n   id NUMBER, name VARCHAR2(50)\n) ON COMMIT DELETE ROWS;\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#q24-what-are-sequences-in-oracle","title":"Q24. What are Sequences in Oracle?","text":"<ul> <li>Object used to generate unique numbers automatically. <pre><code>CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1;\nINSERT INTO employees VALUES (emp_seq.NEXTVAL, 'Mohan', 5000);\n</code></pre></li> </ul>"},{"location":"Interview/2.sql/#q25-how-do-you-handle-hierarchical-queries-in-oracle","title":"Q25. How do you handle Hierarchical Queries in Oracle?","text":"<p>Using <code>CONNECT BY</code>. <pre><code>SELECT employee_id, manager_id, LEVEL\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n</code></pre></p>"},{"location":"Interview/3.plsql/","title":"Plsql-Intro","text":"<p>````markdown</p>"},{"location":"Interview/3.plsql/#oracle-plsql-interview-questions-answers-concept-scenario","title":"Oracle PL/SQL Interview Questions &amp; Answers (Concept \u2192 Scenario)","text":""},{"location":"Interview/3.plsql/#q1-procedure-vs-function","title":"Q1. Procedure vs Function","text":"<p>Concept: - A procedure performs actions and may/may not return a value. Used for tasks like DML and workflows. Cannot be called directly in SQL. - A function must return a single value and can be used inside SQL (SELECT, WHERE). Expected to be computation-focused.  </p> <p>Scenario: I used a procedure to process monthly payroll (insert/update salary records). I built a function to calculate employee tax % and called it inside a SELECT query for reports.</p>"},{"location":"Interview/3.plsql/#q2-cursors-implicit-explicit-ref-for-update-where-current-of-bulk-collect-forall","title":"Q2. Cursors \u2014 implicit, explicit, REF, <code>FOR UPDATE</code> / <code>WHERE CURRENT OF</code>, BULK COLLECT &amp; FORALL","text":"<p>Concept: - Implicit cursors: Oracle manages automatically for single-row queries/DML. - Explicit cursors: Declared explicitly with <code>OPEN</code>, <code>FETCH</code>, <code>CLOSE</code>. - REF cursors: Cursor variables for dynamic queries (strong/weak). - <code>FOR UPDATE</code> locks rows, <code>WHERE CURRENT OF</code> updates/deletes current row. - BULK COLLECT fetches multiple rows in one go; FORALL performs mass DML with collections.  </p> <p>Scenario: I fetched 10k rows with BULK COLLECT and used FORALL for inserts in ETL. It reduced processing time from hours to minutes.</p>"},{"location":"Interview/3.plsql/#q3-type-vs-rowtype","title":"Q3. %TYPE vs %ROWTYPE","text":"<p>Concept: - <code>%TYPE</code>: Variable inherits datatype of a column/variable. - <code>%ROWTYPE</code>: Record variable representing all columns of a table/cursor row.  </p> <p>Scenario: I used <code>%TYPE</code> for salary variable (<code>v_sal employees.salary%TYPE</code>). For full row fetch, I used <code>%ROWTYPE</code> to get all employee details at once.</p>"},{"location":"Interview/3.plsql/#q4-triggers-dml-ddl-database-instead-of-row-vs-statement","title":"Q4. Triggers \u2014 DML, DDL, Database, INSTEAD OF, Row vs Statement","text":"<p>Concept: - DML Triggers \u2192 Fire on INSERT/UPDATE/DELETE. Row-level (<code>FOR EACH ROW</code>) or statement-level. - DDL Triggers \u2192 Fire on CREATE, ALTER, DROP. - Database/System Triggers \u2192 Fire on LOGON, LOGOFF, STARTUP, SHUTDOWN. - INSTEAD OF triggers \u2192 Allow DML on views.  </p> <p>Scenario: I used a row-level DML trigger to log salary changes into an audit table. For reporting, I created an INSTEAD OF INSERT trigger on a view to insert into multiple normalized tables.</p>"},{"location":"Interview/3.plsql/#q5-mutating-table-error","title":"Q5. Mutating Table Error","text":"<p>Concept: Occurs when a row-level trigger queries/updates the same table that fired it. Oracle blocks this to avoid inconsistent reads.  </p> <p>Fixes: - Use statement-level or compound triggers. - Use package collections or temp tables. - Use PRAGMA AUTONOMOUS_TRANSACTION only for logging.  </p> <p>Scenario: In a banking project, a trigger on <code>accounts</code> caused mutating error. I fixed it using a compound trigger with package-level variables.</p>"},{"location":"Interview/3.plsql/#q6-packages-spec-body-advantages","title":"Q6. Packages \u2014 spec &amp; body, advantages","text":"<p>Concept: - Spec: Public declarations (procedures, functions, variables). - Body: Implementation. - Advantages: Encapsulation, modularity, reusability, better performance.  </p> <p>Scenario: I created a <code>payroll_pkg</code> with procedures for salary, bonus, and tax. This improved reusability across modules.</p>"},{"location":"Interview/3.plsql/#q7-pragma-autonomous_transaction","title":"Q7. PRAGMA AUTONOMOUS_TRANSACTION","text":"<p>Concept: Runs as an independent transaction with its own COMMIT/ROLLBACK. Common for logging, auditing.  </p> <p>Scenario: I wrote a logging procedure with AUTONOMOUS_TRANSACTION so error logs were committed even if the main transaction rolled back.</p>"},{"location":"Interview/3.plsql/#q8-exception-handling-raise_application_error","title":"Q8. Exception Handling &amp; RAISE_APPLICATION_ERROR","text":"<p>Concept: - Handle runtime errors with <code>EXCEPTION</code> blocks. - Predefined exceptions: NO_DATA_FOUND, TOO_MANY_ROWS, ZERO_DIVIDE. - User-defined exceptions: Declared/raised explicitly. - <code>RAISE_APPLICATION_ERROR(-20001, 'msg')</code> for custom errors.  </p> <p>Scenario: On data load, I trapped <code>NO_DATA_FOUND</code> and logged it. For business rule violations (like salary &lt; 0), I raised application errors with meaningful messages.</p>"},{"location":"Interview/3.plsql/#q9-dynamic-sql-execute-immediate-vs-dbms_sql","title":"Q9. Dynamic SQL \u2014 <code>EXECUTE IMMEDIATE</code> vs <code>DBMS_SQL</code>","text":"<p>Concept: - <code>EXECUTE IMMEDIATE</code>: Simple, supports binds, RETURNING INTO. - <code>DBMS_SQL</code>: Advanced, for unknown SQL at runtime. - Security: Always use bind variables, validate identifiers with <code>DBMS_ASSERT</code> to prevent SQL injection.  </p> <p>Scenario: I built a reporting module with dynamic filters using EXECUTE IMMEDIATE and bind variables to avoid SQL injection.</p>"},{"location":"Interview/3.plsql/#q10-collections-associative-arrays-nested-tables-varray","title":"Q10. Collections \u2014 Associative Arrays, Nested Tables, VARRAY","text":"<p>Concept: - Associative arrays: In-memory key-value, best for lookups. - Nested tables: Unordered set, can be stored in DB columns. - VARRAY: Bounded, ordered array.  </p> <p>Scenario: I cached product prices using associative arrays. For multi-value attributes, I used nested tables. For fixed small lists (e.g., weekdays), I used VARRAYs.</p>"},{"location":"Interview/3.plsql/#q11-bulk-collect-forall-performance","title":"Q11. BULK COLLECT &amp; FORALL (Performance)","text":"<p>Concept: - BULK COLLECT: Fetch multiple rows into collection in one call. - FORALL: Execute DML in bulk using a collection. - Use <code>LIMIT</code> to avoid memory overload.  </p> <p>Scenario: I rewrote row-by-row ETL into BULK COLLECT + FORALL, cutting runtime from 3 hours to 20 minutes.</p>"},{"location":"Interview/3.plsql/#q12-performance-tuning-techniques","title":"Q12. Performance Tuning \u2014 Techniques","text":"<p>Concept: - Minimize context switches (use bulk ops). - Avoid SELECT *, fetch only required columns. - Use indexes and partitioning. - Analyze execution plans. - Prefer set-based SQL over loops.  </p> <p>Scenario: I replaced a row-by-row update with a MERGE statement \u2014 execution improved drastically.</p>"},{"location":"Interview/3.plsql/#q13-indexing","title":"Q13. Indexing","text":"<p>Concept: - B-Tree: Default, good for high-cardinality. - Bitmap: Good for low-cardinality (DW), not OLTP. - Function-based: Indexes expressions. - Composite: Multi-column index.  </p> <p>Scenario: For a reporting query, I created a composite index <code>(customer_id, txn_date)</code> which reduced query runtime significantly.</p>"},{"location":"Interview/3.plsql/#q14-execution-plans","title":"Q14. Execution Plans","text":"<p>Concept: - Use <code>EXPLAIN PLAN</code> / <code>DBMS_XPLAN.DISPLAY_CURSOR</code> to check joins, access paths. - Watch for full scans, nested loops on large data, missing indexes.  </p> <p>Scenario: I fixed a slow join by adding an index, which changed plan from nested loop to hash join, improving performance.</p>"},{"location":"Interview/3.plsql/#q15-tracing-debugging","title":"Q15. Tracing &amp; Debugging","text":"<p>Concept / Tools: - <code>DBMS_OUTPUT</code> for debugging. - <code>DBMS_PROFILER</code> for performance profiling. - <code>DBMS_UTILITY.FORMAT_ERROR_BACKTRACE</code> for error line info. - <code>SQL_TRACE</code> / TKPROF for SQL-level analysis.  </p> <p>Scenario: I used DBMS_PROFILER to detect a function bottleneck and rewrote it in set-based SQL.</p>"},{"location":"Interview/3.plsql/#q16-sql-plsql-interaction","title":"Q16. SQL &amp; PL/SQL Interaction","text":"<p>Concept: - SQL inside PL/SQL causes context switches. - Minimize with BULK operations, set-based queries. - Use bind variables for better execution plans.  </p> <p>Scenario: Instead of 1000 small queries, I used a single bulk query with BULK COLLECT \u2014 performance improved massively.</p>"},{"location":"Interview/3.plsql/#q17-joins-subqueries","title":"Q17. Joins &amp; Subqueries","text":"<p>Concept: - Joins are usually more efficient than correlated subqueries. - Correlated subqueries run once per row, can be slow. - Replace with joins or analytic functions where possible.  </p> <p>Scenario: I replaced a correlated subquery with a pre-aggregated CTE and join, reducing query time from minutes to seconds.</p>"},{"location":"Interview/3.plsql/#q18-analytic-functions-row_number-rank-lag-lead","title":"Q18. Analytic Functions \u2014 ROW_NUMBER, RANK, LAG, LEAD","text":"<p>Concept: - ROW_NUMBER: Deduplication, pagination. - RANK / DENSE_RANK: Ranking with/without gaps. - LAG/LEAD: Compare with previous/next row.  </p> <p>Scenario: I used LAG to compare current month spend with previous month to detect unusual spikes in customer activity.</p>"},{"location":"Interview/3.plsql/#q19-bulk-data-loading-sqlloader","title":"Q19. Bulk Data Loading \u2014 SQL*Loader","text":"<p>Concept: Oracle utility to load bulk data from external files (CSV, TXT) into tables using control files.  </p> <p>Scenario: I used SQL*Loader in a retail project to load daily sales CSV into staging tables. Control file handled column mapping and skipping invalid rows.</p>"},{"location":"Interview/3.plsql/#q20-real-world-problem-scenarios","title":"Q20. Real-World Problem Scenarios","text":"<p>ETL Performance: Replaced row-by-row load with BULK COLLECT + FORALL, runtime cut by hours. Mutating Trigger: Fixed using compound trigger with package variables. Deadlocks: Used <code>FOR UPDATE SKIP LOCKED</code> and optimized commits.  </p>"},{"location":"Interview/3.plsql/#q21-code-standards-best-practices","title":"Q21. Code Standards &amp; Best Practices","text":"<p>Concept: - Clear naming conventions (<code>pkg_</code>, <code>proc_</code>). - Encapsulation via packages. - Avoid hard-coded literals. - Always handle exceptions. - Unit testing and peer reviews.  </p> <p>Scenario: I enforced package naming standards and code checks in CI pipeline \u2014 reduced production issues.</p>"},{"location":"Interview/3.plsql/#q22-security-in-plsql","title":"Q22. Security in PL/SQL","text":"<p>Concept: - Prevent SQL injection: use bind variables, <code>DBMS_ASSERT</code>. - Apply least privilege principle. - Definer vs Invoker rights (<code>AUTHID</code>). - Handle sensitive data carefully (masking, encryption).  </p> <p>Scenario: I secured dynamic SQL by using bind variables and DBMS_ASSERT. Also restructured schema privileges for least privilege.</p>"},{"location":"Interview/3.plsql/#q23-testing-deployment","title":"Q23. Testing &amp; Deployment","text":"<p>Concept: - Use version control for scripts. - Automate deployments with rollback options. - Test in lower envs before production.  </p> <p>Scenario: I created rollback-capable deployment scripts and added automated unit tests before promoting to prod \u2014 deployment issues reduced.</p>"},{"location":"Interview/3.plsql/#q24-useful-quick-snippets","title":"Q24. Useful Quick Snippets","text":"<p>FOR UPDATE / WHERE CURRENT OF <code>plsql OPEN c FOR SELECT id, balance FROM accounts WHERE status='A' FOR UPDATE; FETCH c INTO v_id, v_balance; UPDATE accounts SET balance = v_balance - 100 WHERE CURRENT OF c; CLOSE c;</code></p> <p>RAISE_APPLICATION_ERROR <code>plsql IF salary &lt; 0 THEN   RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be negative'); END IF;</code></p> <p>BULK COLLECT + FORALL <code>plsql SELECT id, amount BULK COLLECT INTO l_recs FROM txns WHERE batch_id = v_batch; FORALL i IN 1..l_recs.COUNT   UPDATE accounts SET balance = balance + l_recs(i).amount WHERE id = l_recs(i).id;</code></p>"}]}