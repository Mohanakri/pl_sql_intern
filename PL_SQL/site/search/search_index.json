{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PL/SQL Interview Guide","text":"<p>This guide covers SQL, PL/SQL, and Interview Questions. Click below to start exploring \ud83d\udc47</p>"},{"location":"#sections","title":"\ud83d\udcd6 Sections","text":"<ul> <li>Introduction</li> <li>SQL Interview Questions</li> <li>PL/SQL Basics</li> </ul> <p>\ud83d\udca1 Tip: Use the navigation bar at the top for quick access to all topics.</p>"},{"location":"#deploy-to-gh-pages-branch","title":"Deploy to gh-pages branch","text":"<p>mkdocs gh-deploy</p>"},{"location":"Interview/1.Introduction/","title":"Introduction","text":"<p>Hi, I am __, working as a PL/SQL Developer with around 4 years of experience in SQL and PL/SQL development using Oracle 12c/19c. I have worked on development, enhancement, and support projects in domains like Banking, Retail, and Sales.  </p> <p>My expertise includes: - Writing complex SQL queries, stored procedures, functions, packages, and triggers. - SQL performance tuning, exception handling, bulk operations, and data loading using SQL*Loader. - Data modeling (Star and Snowflake schema). - BI reporting tools like QlikView and BI Publisher. - Working in Agile methodology.  </p> <p>I am also involved in client interactions for requirement gathering, effort estimation, and providing regular updates.  </p>"},{"location":"Interview/1.Introduction/#day-to-day-activities-story-style","title":"Day-to-Day Activities (Story Style)","text":"<p>In my project, my day usually starts with a stand-up meeting where I update the team on my progress and plan the day\u2019s work. After that, I check tickets and production logs to see if any jobs or procedures have failed.  </p> <p>Most of my time goes into developing and enhancing PL/SQL objects like procedures, functions, packages, and triggers to meet business requirements. I also work on data loading using SQL*Loader and design database objects such as tables and views when needed.  </p> <p>Alongside development, I spend time testing and debugging the code, optimizing queries for better performance, and fixing any production issues reported by users. I also interact with business analysts and clients to clarify requirements and provide effort estimates.  </p> <p>By the end of the day, I update the task tracker, document the changes, and share my status with the team.  </p>"},{"location":"Interview/2.sql/","title":"sql_interview","text":"<p>Perfect \ud83d\udc4d I\u2019ll reframe your Oracle SQL Interview Q\\&amp;A into the same style as we did for PL/SQL:</p> <p>\ud83d\udc49 Definition \u2192 Concept \u2192 Scenario This ensures you can explain theory, then show practical understanding in interviews.</p> <p>Here\u2019s the full expanded set \ud83d\udc47</p> <p>````markdown</p>"},{"location":"Interview/2.sql/#oracle-sql-interview-questions-answers-definition-concept-scenario","title":"Oracle SQL Interview Questions &amp; Answers (Definition \u2192 Concept \u2192 Scenario)","text":""},{"location":"Interview/2.sql/#1-basic-sql-questions","title":"1. Basic SQL Questions","text":""},{"location":"Interview/2.sql/#q1-difference-between-delete-truncate-and-drop","title":"Q1. Difference between DELETE, TRUNCATE, and DROP","text":"<p>Definition: These are SQL commands used to remove data or objects.  </p> <p>Concept: - DELETE: DML command. Removes specific rows using WHERE or all rows without WHERE. Slower, generates undo logs, rollback possible. - TRUNCATE: DDL command. Removes all rows instantly, frees space, cannot use WHERE, cannot rollback. - DROP: DDL command. Removes the entire table structure and data permanently.  </p> <p>Scenario: In payroll cleanup, I used DELETE to remove test employee data. For clearing staging tables daily, I used TRUNCATE. For decommissioning unused tables, I used DROP.</p>"},{"location":"Interview/2.sql/#q2-difference-between-char-and-varchar2","title":"Q2. Difference between CHAR and VARCHAR2","text":"<p>Definition: Both are string datatypes.  </p> <p>Concept: - CHAR(n): Fixed-length, always occupies n bytes, pads with spaces. - VARCHAR2(n): Variable-length, stores actual length only. Efficient for dynamic text.  </p> <p>Scenario: In a banking app, I used CHAR(10) for IFSC codes (always fixed length) and VARCHAR2 for customer names (variable length).</p>"},{"location":"Interview/2.sql/#q3-difference-between-date-and-timestamp","title":"Q3. Difference between DATE and TIMESTAMP","text":"<p>Definition: Both store date and time data.  </p> <p>Concept: - DATE: Stores date + time up to seconds. - TIMESTAMP: Extends DATE with fractional seconds (up to 9 digits) and optional time zones.  </p> <p>Scenario: In auditing, DATE was enough for employee joining date. For logging transactions, TIMESTAMP was required to track events at millisecond precision.</p>"},{"location":"Interview/2.sql/#q4-difference-between-substr-and-instr","title":"Q4. Difference between SUBSTR and INSTR","text":"<p>Definition: Both are string functions.  </p> <p>Concept: - SUBSTR: Extracts part of a string. - INSTR: Returns position of substring occurrence.  </p> <p>Example: <code>sql SELECT SUBSTR('welcome',1,3) FROM dual; -- wel SELECT INSTR('welcome','e',1,1) FROM dual; -- 2</code> </p> <p>Scenario: In reports, I used SUBSTR to mask credit card numbers (show only last 4 digits). INSTR helped find positions of delimiters in CSV strings.</p>"},{"location":"Interview/2.sql/#q5-what-are-constraints-in-oracle-sql","title":"Q5. What are constraints in Oracle SQL?","text":"<p>Definition: Rules applied to table columns to enforce data integrity.  </p> <p>Concept: - NOT NULL \u2013 Column must have a value. - UNIQUE \u2013 Ensures unique values. - PRIMARY KEY \u2013 Unique + Not Null (one per table). - FOREIGN KEY \u2013 Enforces referential integrity. - CHECK \u2013 Validates condition. - DEFAULT \u2013 Provides default values.  </p> <p>Scenario: In HR system, I enforced PRIMARY KEY on employee_id, CHECK on salary &gt; 0, and FOREIGN KEY on dept_id referencing departments table.</p>"},{"location":"Interview/2.sql/#q6-difference-between-view-and-materialized-view","title":"Q6. Difference between VIEW and MATERIALIZED VIEW","text":"<p>Definition: Views are virtual tables; materialized views are physical copies.  </p> <p>Concept: - VIEW: Logical query stored, always shows live data. - MATERIALIZED VIEW: Stores result physically, refreshable on demand or schedule.  </p> <p>Scenario: For real-time reporting, I used normal views. For heavy sales reports, I used materialized views with daily refresh.</p>"},{"location":"Interview/2.sql/#q7-union-vs-union-all","title":"Q7. UNION vs UNION ALL","text":"<p>Definition: Both combine results of multiple queries.  </p> <p>Concept: - UNION: Removes duplicates, sorts results (slower). - UNION ALL: Keeps duplicates, faster.  </p> <p>Scenario: When combining employee and contractor lists (no duplicates needed), I used UNION. For merging daily transaction logs (duplicates allowed), I used UNION ALL.</p>"},{"location":"Interview/2.sql/#q8-how-to-delete-duplicate-records","title":"Q8. How to delete duplicate records?","text":"<p>Concept: Use ROWID to identify unique physical row IDs.  </p> <p>Example: <code>sql DELETE FROM emp e1 WHERE ROWID &gt; (   SELECT MIN(ROWID)   FROM emp e2   WHERE e2.emp_id = e1.emp_id );</code> </p> <p>Scenario: I cleaned duplicate sales records by keeping the first occurrence and deleting others using ROWID.</p>"},{"location":"Interview/2.sql/#q9-rank-vs-dense_rank","title":"Q9. RANK vs DENSE_RANK","text":"<p>Definition: Both are analytic functions.  </p> <p>Concept: - RANK: Skips numbers for ties. - DENSE_RANK: No gaps, consecutive ranking.  </p> <p>Scenario: In incentive calculation, I used RANK to give same rank to ties but skip numbers. In exam results, I used DENSE_RANK to assign consecutive ranks without gaps.</p>"},{"location":"Interview/2.sql/#q10-right-join-vs-left-join","title":"Q10. Right Join vs Left Join","text":"<p>Concept: - LEFT JOIN: All rows from left table + matched rows from right. - RIGHT JOIN: All rows from right + matched rows from left.  </p> <p>Scenario: To list all employees (even without departments), I used LEFT JOIN. To list all departments (even without employees), I used RIGHT JOIN.</p>"},{"location":"Interview/2.sql/#q11-why-do-we-use-joins-types","title":"Q11. Why do we use Joins? Types?","text":"<p>Definition: Joins combine data from multiple tables.  </p> <p>Concept: Types: Inner, Outer (Left/Right/Full), Cross, Self, Equi, Non-Equi.  </p> <p>Scenario: In HR module, I joined employees with departments to fetch employee name + department name.</p>"},{"location":"Interview/2.sql/#2-intermediate-sql-questions","title":"2. Intermediate SQL Questions","text":""},{"location":"Interview/2.sql/#q12-what-are-indexes-types-of-indexes-in-oracle","title":"Q12. What are indexes? Types of indexes in Oracle?","text":"<p>Definition: Indexes are objects that improve data retrieval speed.  </p> <p>Concept: - B-tree (default, balanced). - Bitmap (low-cardinality, DW). - Function-based (on expressions). - Composite (multi-column). - Unique/Non-unique.  </p> <p>Scenario: I used composite index (dept_id, hire_date) to speed up hiring reports. For gender column, bitmap index was used in analytics.</p>"},{"location":"Interview/2.sql/#q13-aggregate-vs-analytic-functions","title":"Q13. Aggregate vs Analytic functions","text":"<p>Definition: Both perform calculations.  </p> <p>Concept: - Aggregate: Group-level (SUM, AVG, MAX, MIN). Collapse rows. - Analytic: Row-level over a window (RANK, ROW_NUMBER, LAG).  </p> <p>Scenario: For salary reports, I used AVG() for department salary. To show each employee\u2019s rank by salary, I used RANK() analytic.</p>"},{"location":"Interview/2.sql/#q14-subqueries-vs-correlated-subqueries","title":"Q14. Subqueries vs Correlated Subqueries","text":"<p>Definition: Query inside another query.  </p> <p>Concept: - Subquery: Executes once, result reused. - Correlated: Executes for each outer row.  </p> <p>Scenario: To find employees in IT department, I used a simple subquery. To compare employee salary with department average, I used correlated subquery.</p>"},{"location":"Interview/2.sql/#3-advanced-sql-questions","title":"3. Advanced SQL Questions","text":""},{"location":"Interview/2.sql/#q15-rownum-vs-row_number","title":"Q15. ROWNUM vs ROW_NUMBER()","text":"<p>Definition: Both assign row numbers.  </p> <p>Concept: - ROWNUM: Pseudocolumn, assigned before ORDER BY. - ROW_NUMBER(): Analytic, assigns after ORDER BY.  </p> <p>Scenario: To fetch first 10 rows quickly, I used ROWNUM. For pagination (ordered results), I used ROW_NUMBER().</p>"},{"location":"Interview/2.sql/#q16-exists-vs-in","title":"Q16. EXISTS vs IN","text":"<p>Definition: Both check membership.  </p> <p>Concept: - IN: Checks value in list. Good for small lists. - EXISTS: Returns TRUE if subquery has rows. Efficient for correlated queries.  </p> <p>Scenario: For small filter lists, I used IN. For checking employee existence in departments, I used EXISTS (faster for large datasets).</p>"},{"location":"Interview/2.sql/#q17-how-to-find-the-2nd-highest-salary","title":"Q17. How to find the 2nd highest salary?","text":"<p>Concept: Multiple methods.  </p> <p>Example: ```sql -- Subquery SELECT MAX(salary) FROM employees WHERE salary &lt; (SELECT MAX(salary) FROM employees);</p> <p>-- Analytic SELECT salary FROM (   SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS rnk   FROM employees ) WHERE rnk = 2; ```  </p> <p>Scenario: I used analytic functions for ranking salaries and fetching 2nd/3rd highest directly in reporting queries.</p>"},{"location":"Interview/2.sql/#q18-delete-with-where-vs-cascade-delete","title":"Q18. DELETE with WHERE vs Cascade Delete","text":"<p>Concept: - DELETE with WHERE: Deletes chosen rows. - Cascade Delete: Automatically deletes dependent child rows.  </p> <p>Scenario: When removing a department, I used CASCADE DELETE to automatically remove all employee rows linked to it.</p>"},{"location":"Interview/2.sql/#q19-how-to-improve-sql-performance","title":"Q19. How to improve SQL performance?","text":"<p>Concept: - Use indexes properly. - Avoid SELECT *. - Use bind variables. - Rewrite correlated subqueries as joins. - Partition large tables. - Analyze execution plan with DBMS_XPLAN.  </p> <p>Scenario: A sales report query ran for 25 minutes; I added a composite index and rewrote correlated subquery as join. It ran in under 2 minutes.</p>"},{"location":"Interview/2.sql/#q20-what-is-a-cte-with-clause","title":"Q20. What is a CTE (WITH clause)?","text":"<p>Definition: A Common Table Expression is a temporary named query.  </p> <p>Concept: Improves readability and reusability.  </p> <p>Example: <code>sql WITH dept_avg AS (    SELECT dept_id, AVG(salary) AS avg_sal    FROM employees    GROUP BY dept_id ) SELECT e.name, e.salary, d.avg_sal FROM employees e JOIN dept_avg d ON e.dept_id = d.dept_id;</code> </p> <p>Scenario: I used CTEs in ETL scripts to break complex queries into smaller logical blocks.</p>"},{"location":"Interview/2.sql/#q21-merge-statement","title":"Q21. MERGE statement","text":"<p>Definition: MERGE = Insert + Update (UPSERT).  </p> <p>Concept: Updates if row exists, inserts if not.  </p> <p>Scenario: In data sync jobs, I merged staging data into master employee table daily using MERGE.</p>"},{"location":"Interview/2.sql/#q22-primary-key-vs-unique","title":"Q22. PRIMARY KEY vs UNIQUE","text":"<p>Concept: - PRIMARY KEY: One per table, enforces uniqueness + not null. - UNIQUE: Allows nulls, multiple allowed per table.  </p> <p>Scenario: Employee table had PRIMARY KEY on emp_id, but UNIQUE constraint on email_id.</p>"},{"location":"Interview/2.sql/#q23-global-temporary-tables-gtt","title":"Q23. Global Temporary Tables (GTT)","text":"<p>Definition: Tables where data is session or transaction-specific.  </p> <p>Concept: - Structure is permanent. - Data cleared on COMMIT or session end.  </p> <p>Scenario: I used GTT for intermediate calculations in payroll \u2014 data cleared automatically after session.</p>"},{"location":"Interview/2.sql/#q24-sequences","title":"Q24. Sequences","text":"<p>Definition: Schema object that generates unique numbers.  </p> <p>Concept: - Used for primary keys. - NEXTVAL for next number, CURRVAL for current.  </p> <p>Scenario: I used sequences for emp_id auto-generation during inserts.</p>"},{"location":"Interview/2.sql/#q25-hierarchical-queries-in-oracle","title":"Q25. Hierarchical Queries in Oracle","text":"<p>Definition: Queries that represent parent-child relationships.  </p> <p>Concept: - Done with <code>CONNECT BY</code> and <code>START WITH</code>.  </p> <p>Example: <code>sql SELECT employee_id, manager_id, LEVEL FROM employees START WITH manager_id IS NULL CONNECT BY PRIOR employee_id = manager_id;</code> </p> <p>Scenario: I used hierarchical queries to generate org charts (employee \u2192 manager chain).</p> <p>\u2705 Now both SQL &amp; PL/SQL docs are uniform with Definition \u2192 Concept \u2192 Scenario.</p> <p>Do you want me to merge both into one master document (SQL + PL/SQL, \\~50 Q\\&amp;A) so you can prepare from a single source?</p>"},{"location":"Interview/3.plsql/","title":"Plsql-Intro","text":"<p>Sure! Here's a consolidated table of all key PL/SQL and related Oracle definitions, including <code>SQL*Loader</code>, <code>BULK COLLECT</code>, and <code>FORALL</code>, perfect for interview preparation:</p>"},{"location":"Interview/3.plsql/#plsql-and-oracle-definitions-table","title":"\u2705 PL/SQL and Oracle Definitions Table","text":"Term Definition PL/SQL Procedural Language extension of SQL developed by Oracle to combine SQL with procedural programming. Block The basic unit of PL/SQL code. Contains declarations, executable statements, and exception handling. Anonymous Block A PL/SQL block without a name, not stored in the database, and executed once. Named Block A PL/SQL block that is stored in the database with a name (procedures, functions, etc.). Variable A named storage location used to hold data temporarily during PL/SQL execution. Cursor A pointer to the result set of a SQL query, used to process multiple rows. Implicit Cursor Automatically created by Oracle when a DML statement is executed. Explicit Cursor Manually declared by the programmer to handle multiple row queries. Exception An error condition during program execution. Can be predefined or user-defined. Trigger A PL/SQL block that executes automatically in response to database events (INSERT, UPDATE, DELETE). Procedure A stored PL/SQL block that performs an action. It does not return a value directly. Function A stored PL/SQL block that returns a single value and can be used in SQL statements. Package A collection of related procedures, functions, variables, and cursors grouped together. Record A composite data type in PL/SQL that can hold multiple fields of different data types. Loop A control structure that repeats a block of code. IF...THEN...ELSE A conditional control structure to execute code based on conditions. WHILE LOOP Executes a block of code repeatedly as long as a condition is TRUE. FOR LOOP Executes a block of code a fixed number of times. SQL*Loader Oracle utility used to load data from external files into Oracle database tables. Control File (SQL*Loader) A configuration file used by SQL*Loader to define how data is read and loaded. Direct Path Load (SQL*Loader) Loads data by bypassing SQL processing for faster performance. Conventional Path Load (SQL*Loader) Loads data using standard SQL INSERT operations. BULK COLLECT Retrieves multiple rows from a query into a PL/SQL collection in a single fetch, improving performance. FORALL Performs DML operations in bulk using collections, reducing context switching and improving performance. Limit Clause (with BULK COLLECT) Restricts the number of rows fetched at a time into a collection to avoid memory issues. Binding Variables (SQL*Loader) Placeholders used to pass values into SQL*Loader control files dynamically. %FOUND Returns TRUE if a DML operation affected one or more rows. %NOTFOUND Returns TRUE if a DML operation did not affect any rows. %ROWCOUNT Returns the number of rows affected by a DML statement. %ISOPEN Returns TRUE if a cursor is currently open. NO_DATA_FOUND Predefined exception raised when a SELECT INTO query returns no rows. TOO_MANY_ROWS Predefined exception raised when a SELECT INTO query returns more than one row. ZERO_DIVIDE Predefined exception raised when a division by zero occurs. VALUE_ERROR Predefined exception raised when there is a data type mismatch or assignment error. <p>Let me know if you\u2019d like this in:</p> <ul> <li>\ud83d\udcc4 PDF format</li> <li>\ud83d\udccb Word/Excel format</li> <li>\ud83d\udca1 Flashcards for practice</li> </ul>"},{"location":"Interview/3.plsql/#i-can-also-provide-top-interview-questions-based-on-these-terms-if-youd-like-to-go-deeper","title":"I can also provide top interview questions based on these terms if you'd like to go deeper.","text":"<p>Got it \u2705 \u2014 you want a full interview-prep doc where every answer has:</p> <ol> <li>Definition / Concept (clear theory).</li> <li>Examples / Scenarios (real-world use cases you can narrate).</li> <li>Best Practices / Notes (where applicable).</li> </ol> <p>What you pasted is already excellent, but I\u2019ll expand the \u201cConcept\u201d parts with proper definitions and fundamentals \u2014 so you can confidently answer \u201cwhat is it?\u201d before jumping into \u201chow I used it\u201d.</p> <p>Here\u2019s the refined, full set \ud83d\udc47 (you can drop it straight into MkDocs).</p> <p>````markdown</p>"},{"location":"Interview/3.plsql/#oracle-plsql-interview-questions-answers-definition-concept-scenario","title":"Oracle PL/SQL Interview Questions &amp; Answers (Definition \u2192 Concept \u2192 Scenario)","text":""},{"location":"Interview/3.plsql/#q1-procedure-vs-function","title":"Q1. Procedure vs Function","text":"<p>Definition: - A procedure is a named PL/SQL block that performs one or more actions. It may or may not return a value. - A function is a named PL/SQL block that must return exactly one value using the <code>RETURN</code> keyword.  </p> <p>Concept: - Procedures are generally used for business logic and workflows (like inserts, updates, validations). - Functions are used for calculations and can be embedded in SQL queries. - Functions should ideally be free of side effects when used inside SQL.  </p> <p>Scenario: I used a procedure to insert payroll records and validate salary ranges. I created a function to calculate tax percentage, which I called inside a SELECT query when generating salary reports.</p>"},{"location":"Interview/3.plsql/#q2-cursors-implicit-explicit-ref-for-update-where-current-of-bulk-collect-forall","title":"Q2. Cursors \u2014 implicit, explicit, REF, <code>FOR UPDATE</code> / <code>WHERE CURRENT OF</code>, BULK COLLECT &amp; FORALL","text":"<p>Definition: A cursor is a pointer to the memory area (context area) where Oracle stores the result of a SQL query.  </p> <p>Concept: - Implicit cursors: Managed automatically by Oracle for single-row operations. - Explicit cursors: Declared by the developer for multi-row queries (<code>OPEN</code>, <code>FETCH</code>, <code>CLOSE</code>). - REF cursors: Cursor variables that can point to different queries (dynamic). - <code>FOR UPDATE</code> \u2192 Locks rows when fetching, <code>WHERE CURRENT OF</code> \u2192 allows updates/deletes on the fetched row. - BULK COLLECT: Fetch multiple rows at once into a collection. - FORALL: Perform DML in bulk using collections.  </p> <p>Scenario: In ETL processing, I fetched 10,000 rows with BULK COLLECT and updated them using FORALL. This reduced runtime from hours to minutes.</p>"},{"location":"Interview/3.plsql/#q3-type-vs-rowtype","title":"Q3. %TYPE vs %ROWTYPE","text":"<p>Definition: - <code>%TYPE</code>: Defines a variable with the datatype of a table column or another variable. - <code>%ROWTYPE</code>: Defines a record that can hold an entire row of a table or cursor.  </p> <p>Concept: They make code schema-independent. If the column datatype changes, the PL/SQL code automatically adapts.  </p> <p>Scenario: I declared <code>v_salary employees.salary%TYPE</code> to always match the salary column type. For fetching entire employee details, I used <code>emp_rec employees%ROWTYPE</code>.</p>"},{"location":"Interview/3.plsql/#q4-triggers-dml-ddl-database-instead-of-row-vs-statement","title":"Q4. Triggers \u2014 DML, DDL, Database, INSTEAD OF, Row vs Statement","text":"<p>Definition: A trigger is a stored PL/SQL block that executes automatically in response to specific database events.  </p> <p>Concept: - DML triggers: Fire on <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>. Can be row-level or statement-level. - DDL triggers: Fire on schema events like <code>CREATE</code>, <code>DROP</code>, <code>ALTER</code>. - Database triggers: Fire on events like LOGON, LOGOFF, STARTUP. - INSTEAD OF triggers: Allow DML on complex views.  </p> <p>Scenario: I created a row-level trigger on the <code>employees</code> table to log salary updates. I also created an INSTEAD OF trigger on a reporting view to insert data into multiple normalized tables.</p>"},{"location":"Interview/3.plsql/#q5-mutating-table-error","title":"Q5. Mutating Table Error","text":"<p>Definition: A mutating table error occurs when a row-level trigger tries to read/modify the same table that fired it.  </p> <p>Concept: Oracle raises this error to prevent inconsistent reads.  </p> <p>Fixes: - Use statement-level or compound triggers. - Use package-level collections or staging tables. - Use PRAGMA AUTONOMOUS_TRANSACTION for logging only.  </p> <p>Scenario: In a banking project, an update trigger on <code>accounts</code> failed due to mutating error. I fixed it using a compound trigger and package variable.</p>"},{"location":"Interview/3.plsql/#q6-packages","title":"Q6. Packages","text":"<p>Definition: A package is a schema object that groups procedures, functions, variables, cursors, and exceptions into one unit.  </p> <p>Concept: - Specification: Public interface. - Body: Implementation. - Advantages: Encapsulation, reusability, performance (loaded once into memory).  </p> <p>Scenario: I built a payroll package with procedures for salary insertion, bonus, and tax. It centralized business logic and reduced duplication.</p>"},{"location":"Interview/3.plsql/#q7-pragma-autonomous_transaction","title":"Q7. PRAGMA AUTONOMOUS_TRANSACTION","text":"<p>Definition: A pragma is a compiler directive. AUTONOMOUS_TRANSACTION makes a block run as an independent transaction.  </p> <p>Concept: - Allows COMMIT/ROLLBACK inside a procedure, function, or trigger without affecting the main transaction. - Used for logging, auditing.  </p> <p>Scenario: I created a log procedure with AUTONOMOUS_TRANSACTION so error logs were saved even if the payroll transaction rolled back.</p>"},{"location":"Interview/3.plsql/#q8-exception-handling-raise_application_error","title":"Q8. Exception Handling &amp; RAISE_APPLICATION_ERROR","text":"<p>Definition: Exceptions handle runtime errors in PL/SQL.  </p> <p>Concept: - Predefined exceptions: NO_DATA_FOUND, TOO_MANY_ROWS, ZERO_DIVIDE, etc. - User-defined exceptions: Declared by developer. - <code>RAISE_APPLICATION_ERROR</code>: Raise custom application errors (-20000 to -20999).  </p> <p>Scenario: I handled <code>NO_DATA_FOUND</code> gracefully with a message, and raised custom exceptions for invalid salaries using <code>RAISE_APPLICATION_ERROR</code>.</p>"},{"location":"Interview/3.plsql/#q9-dynamic-sql-execute-immediate-vs-dbms_sql","title":"Q9. Dynamic SQL \u2014 EXECUTE IMMEDIATE vs DBMS_SQL","text":"<p>Definition: Dynamic SQL is SQL whose structure is not known until runtime.  </p> <p>Concept: - <code>EXECUTE IMMEDIATE</code>: Easy, supports bind variables, RETURNING INTO. - <code>DBMS_SQL</code>: Advanced, useful for fully dynamic queries. - Security: Always use binds and validate identifiers to avoid SQL injection.  </p> <p>Scenario: I created a reporting tool where filters were dynamic. I used EXECUTE IMMEDIATE with bind variables for security.</p>"},{"location":"Interview/3.plsql/#q10-collections-associative-arrays-nested-tables-varray","title":"Q10. Collections \u2014 Associative Arrays, Nested Tables, VARRAY","text":"<p>Definition: Collections are PL/SQL datatypes for storing multiple values.  </p> <p>Concept: - Associative arrays: Key-value pairs, in-memory only. - Nested tables: Unordered, can be stored in DB. - VARRAY: Ordered, with a fixed maximum size.  </p> <p>Scenario: I cached frequently accessed prices using associative arrays. For multi-tag storage, I used nested tables. For fixed lists like weekdays, I used VARRAYs.</p>"},{"location":"Interview/3.plsql/#q11-bulk-collect-forall","title":"Q11. BULK COLLECT &amp; FORALL","text":"<p>Definition: - BULK COLLECT: Fetch multiple rows into a collection at once. - FORALL: Perform bulk DML using a collection.  </p> <p>Concept: They minimize context switches between SQL and PL/SQL.  </p> <p>Scenario: I used BULK COLLECT + FORALL in ETL, cutting runtime from 3 hours to 20 minutes.</p>"},{"location":"Interview/3.plsql/#q12-performance-tuning-techniques","title":"Q12. Performance Tuning \u2014 Techniques","text":"<p>Definition: Performance tuning optimizes PL/SQL for speed and efficiency.  </p> <p>Concept: - Avoid row-by-row (slow by slow). - Use set-based SQL where possible. - Use indexes and partitions wisely. - Avoid SELECT *. - Analyze execution plans.  </p> <p>Scenario: I replaced a cursor-based update with a MERGE. The runtime dropped drastically.</p>"},{"location":"Interview/3.plsql/#q13-indexing","title":"Q13. Indexing","text":"<p>Definition: An index is a schema object that speeds up row retrieval.  </p> <p>Concept: - B-tree: Default, good for high-cardinality. - Bitmap: Good for low-cardinality (DW). - Function-based: Index expressions. - Composite: Multi-column.  </p> <p>Scenario: For a slow report query, I created a composite index <code>(cust_id, txn_date)</code>, reducing runtime from minutes to seconds.</p>"},{"location":"Interview/3.plsql/#q14-execution-plans","title":"Q14. Execution Plans","text":"<p>Definition: An execution plan shows how Oracle executes a SQL query.  </p> <p>Concept: - Use <code>EXPLAIN PLAN</code> or <code>DBMS_XPLAN</code>. - Look for full scans, join types, access paths.  </p> <p>Scenario: I improved performance by creating an index, which changed a nested loop to a hash join.</p>"},{"location":"Interview/3.plsql/#q15-tracing-debugging","title":"Q15. Tracing &amp; Debugging","text":"<p>Definition: Tracing/debugging tools help identify errors and performance issues.  </p> <p>Concept: - <code>DBMS_OUTPUT</code> for prints. - <code>DBMS_PROFILER</code> for performance profiling. - <code>DBMS_UTILITY.FORMAT_ERROR_BACKTRACE</code> for error stack. - TKPROF/SQL_TRACE for SQL-level tracing.  </p> <p>Scenario: I used DBMS_PROFILER to locate a slow function and rewrote it with set-based SQL.</p>"},{"location":"Interview/3.plsql/#q16-sql-plsql-interaction","title":"Q16. SQL &amp; PL/SQL Interaction","text":"<p>Definition: PL/SQL is tightly integrated with SQL, but crossing engines causes context switching.  </p> <p>Concept: - Minimize switches with bulk operations. - Use bind variables for plan reuse.  </p> <p>Scenario: Instead of executing 1000 small queries, I used BULK COLLECT in one query, reducing runtime.</p>"},{"location":"Interview/3.plsql/#q17-joins-subqueries","title":"Q17. Joins &amp; Subqueries","text":"<p>Definition: A join combines rows from multiple tables. A subquery is a query inside another query.  </p> <p>Concept: - Joins are usually more efficient. - Correlated subqueries run per row, slower. - Use analytic functions or CTEs instead.  </p> <p>Scenario: I replaced a correlated subquery with a CTE and join, reducing query runtime from 20 minutes to 2.</p>"},{"location":"Interview/3.plsql/#q18-analytic-functions","title":"Q18. Analytic Functions","text":"<p>Definition: Analytic functions return values based on groups of rows, without collapsing results.  </p> <p>Concept: - <code>ROW_NUMBER()</code> \u2192 Deduplication, pagination. - <code>RANK()</code>, <code>DENSE_RANK()</code> \u2192 Ranking. - <code>LAG()</code>, <code>LEAD()</code> \u2192 Compare rows.  </p> <p>Scenario: I used LAG to compare customer spend month-over-month to detect unusual spikes.</p>"},{"location":"Interview/3.plsql/#q19-bulk-data-loading-sqlloader","title":"Q19. Bulk Data Loading \u2014 SQL*Loader","text":"<p>Definition: SQL*Loader is a utility for high-speed data loading into Oracle.  </p> <p>Concept: - Loads data from external files into tables. - Uses a control file to define mappings.  </p> <p>Scenario: I used SQL*Loader to load daily sales CSV into staging tables in a retail project.</p>"},{"location":"Interview/3.plsql/#q20-real-world-problem-scenarios","title":"Q20. Real-World Problem Scenarios","text":"<ul> <li>ETL Performance: Replaced row-by-row load with BULK COLLECT + FORALL, cut runtime by hours.  </li> <li>Mutating Trigger: Fixed using compound trigger and package variables.  </li> <li>Deadlocks: Used <code>FOR UPDATE SKIP LOCKED</code> and reduced transaction size.  </li> </ul>"},{"location":"Interview/3.plsql/#q21-code-standards-best-practices","title":"Q21. Code Standards &amp; Best Practices","text":"<p>Definition: Best practices ensure maintainable, reusable, and error-free code.  </p> <p>Concept: - Clear naming conventions. - Modular code in packages. - Avoid hard-coded values. - Always handle exceptions. - Unit testing + peer reviews.  </p> <p>Scenario: I introduced naming standards and pre-commit checks, reducing production bugs.</p>"},{"location":"Interview/3.plsql/#q22-security-in-plsql","title":"Q22. Security in PL/SQL","text":"<p>Definition: PL/SQL must be secured against SQL injection and privilege misuse.  </p> <p>Concept: - Use bind variables and DBMS_ASSERT. - Apply least privilege. - Use AUTHID DEFINER vs CURRENT_USER correctly.  </p> <p>Scenario: I secured dynamic SQL with bind variables and DBMS_ASSERT, and moved sensitive operations to a restricted schema.</p>"},{"location":"Interview/3.plsql/#q23-testing-deployment","title":"Q23. Testing &amp; Deployment","text":"<p>Definition: Controlled deployment reduces risk of production issues.  </p> <p>Concept: - Keep code in version control. - Automate deployments with rollback. - Test in dev/test before prod.  </p> <p>Scenario: I wrote rollback-capable scripts and automated unit tests, reducing deployment failures.</p>"},{"location":"Interview/3.plsql/#q24-useful-quick-snippets","title":"Q24. Useful Quick Snippets","text":"<p>FOR UPDATE / WHERE CURRENT OF <code>plsql OPEN c FOR SELECT id, balance FROM accounts WHERE status='A' FOR UPDATE; FETCH c INTO v_id, v_balance; UPDATE accounts SET balance = v_balance - 100 WHERE CURRENT OF c; CLOSE c;</code></p> <p>RAISE_APPLICATION_ERROR <code>plsql IF salary &lt; 0 THEN   RAISE_APPLICATION_ERROR(-20001, 'Salary cannot be negative'); END IF;</code></p> <p>BULK COLLECT + FORALL <code>plsql SELECT id, amount BULK COLLECT INTO l_recs FROM txns WHERE batch_id = v_batch; FORALL i IN 1..l_recs.COUNT   UPDATE accounts SET balance = balance + l_recs(i).amount WHERE id = l_recs(i).id;</code></p> <p>\u2705 This is now definition + concept + scenario for all important PL/SQL interview topics (basic \u2192 advanced \u2192 real-world).</p> <p>Would you like me to make a parallel one for SQL (definitions + concepts + scenarios for the 25 SQL Q\\&amp;A we built earlier) so you have a single combined SQL + PL/SQL master doc?</p>"}]}