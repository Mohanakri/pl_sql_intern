Perfect 👍 I’ll reframe your **Oracle SQL Interview Q\&A** into the same style as we did for PL/SQL:

👉 **Definition → Concept → Scenario**
This ensures you can explain theory, then show practical understanding in interviews.

Here’s the **full expanded set** 👇

---

````markdown
# Oracle SQL Interview Questions & Answers (Definition → Concept → Scenario)

---

## 1. Basic SQL Questions

### Q1. Difference between DELETE, TRUNCATE, and DROP  
**Definition:** These are SQL commands used to remove data or objects.  

**Concept:**  
- **DELETE**: DML command. Removes specific rows using WHERE or all rows without WHERE. Slower, generates undo logs, rollback possible.  
- **TRUNCATE**: DDL command. Removes all rows instantly, frees space, cannot use WHERE, cannot rollback.  
- **DROP**: DDL command. Removes the entire table structure and data permanently.  

**Scenario:**  
In payroll cleanup, I used DELETE to remove test employee data. For clearing staging tables daily, I used TRUNCATE. For decommissioning unused tables, I used DROP.

---

### Q2. Difference between CHAR and VARCHAR2  
**Definition:** Both are string datatypes.  

**Concept:**  
- **CHAR(n)**: Fixed-length, always occupies n bytes, pads with spaces.  
- **VARCHAR2(n)**: Variable-length, stores actual length only. Efficient for dynamic text.  

**Scenario:**  
In a banking app, I used CHAR(10) for IFSC codes (always fixed length) and VARCHAR2 for customer names (variable length).

---

### Q3. Difference between DATE and TIMESTAMP  
**Definition:** Both store date and time data.  

**Concept:**  
- **DATE**: Stores date + time up to seconds.  
- **TIMESTAMP**: Extends DATE with fractional seconds (up to 9 digits) and optional time zones.  

**Scenario:**  
In auditing, DATE was enough for employee joining date. For logging transactions, TIMESTAMP was required to track events at millisecond precision.

---

### Q4. Difference between SUBSTR and INSTR  
**Definition:** Both are string functions.  

**Concept:**  
- **SUBSTR**: Extracts part of a string.  
- **INSTR**: Returns position of substring occurrence.  

**Example:**  
```sql
SELECT SUBSTR('welcome',1,3) FROM dual; -- wel
SELECT INSTR('welcome','e',1,1) FROM dual; -- 2
```  

**Scenario:**  
In reports, I used SUBSTR to mask credit card numbers (show only last 4 digits). INSTR helped find positions of delimiters in CSV strings.

---

### Q5. What are constraints in Oracle SQL?  
**Definition:** Rules applied to table columns to enforce data integrity.  

**Concept:**  
- **NOT NULL** – Column must have a value.  
- **UNIQUE** – Ensures unique values.  
- **PRIMARY KEY** – Unique + Not Null (one per table).  
- **FOREIGN KEY** – Enforces referential integrity.  
- **CHECK** – Validates condition.  
- **DEFAULT** – Provides default values.  

**Scenario:**  
In HR system, I enforced PRIMARY KEY on employee_id, CHECK on salary > 0, and FOREIGN KEY on dept_id referencing departments table.

---

### Q6. Difference between VIEW and MATERIALIZED VIEW  
**Definition:** Views are virtual tables; materialized views are physical copies.  

**Concept:**  
- **VIEW**: Logical query stored, always shows live data.  
- **MATERIALIZED VIEW**: Stores result physically, refreshable on demand or schedule.  

**Scenario:**  
For real-time reporting, I used normal views. For heavy sales reports, I used materialized views with daily refresh.

---

### Q7. UNION vs UNION ALL  
**Definition:** Both combine results of multiple queries.  

**Concept:**  
- **UNION**: Removes duplicates, sorts results (slower).  
- **UNION ALL**: Keeps duplicates, faster.  

**Scenario:**  
When combining employee and contractor lists (no duplicates needed), I used UNION. For merging daily transaction logs (duplicates allowed), I used UNION ALL.

---

### Q8. How to delete duplicate records?  
**Concept:** Use ROWID to identify unique physical row IDs.  

**Example:**  
```sql
DELETE FROM emp e1
WHERE ROWID > (
  SELECT MIN(ROWID)
  FROM emp e2
  WHERE e2.emp_id = e1.emp_id
);
```  

**Scenario:**  
I cleaned duplicate sales records by keeping the first occurrence and deleting others using ROWID.

---

### Q9. RANK vs DENSE_RANK  
**Definition:** Both are analytic functions.  

**Concept:**  
- **RANK**: Skips numbers for ties.  
- **DENSE_RANK**: No gaps, consecutive ranking.  

**Scenario:**  
In incentive calculation, I used RANK to give same rank to ties but skip numbers. In exam results, I used DENSE_RANK to assign consecutive ranks without gaps.

---

### Q10. Right Join vs Left Join  
**Concept:**  
- **LEFT JOIN**: All rows from left table + matched rows from right.  
- **RIGHT JOIN**: All rows from right + matched rows from left.  

**Scenario:**  
To list all employees (even without departments), I used LEFT JOIN. To list all departments (even without employees), I used RIGHT JOIN.

---

### Q11. Why do we use Joins? Types?  
**Definition:** Joins combine data from multiple tables.  

**Concept:**  
Types: Inner, Outer (Left/Right/Full), Cross, Self, Equi, Non-Equi.  

**Scenario:**  
In HR module, I joined employees with departments to fetch employee name + department name.

---

## 2. Intermediate SQL Questions

### Q12. What are indexes? Types of indexes in Oracle?  
**Definition:** Indexes are objects that improve data retrieval speed.  

**Concept:**  
- **B-tree** (default, balanced).  
- **Bitmap** (low-cardinality, DW).  
- **Function-based** (on expressions).  
- **Composite** (multi-column).  
- **Unique/Non-unique**.  

**Scenario:**  
I used composite index (dept_id, hire_date) to speed up hiring reports. For gender column, bitmap index was used in analytics.

---

### Q13. Aggregate vs Analytic functions  
**Definition:** Both perform calculations.  

**Concept:**  
- **Aggregate**: Group-level (SUM, AVG, MAX, MIN). Collapse rows.  
- **Analytic**: Row-level over a window (RANK, ROW_NUMBER, LAG).  

**Scenario:**  
For salary reports, I used AVG() for department salary. To show each employee’s rank by salary, I used RANK() analytic.

---

### Q14. Subqueries vs Correlated Subqueries  
**Definition:** Query inside another query.  

**Concept:**  
- **Subquery**: Executes once, result reused.  
- **Correlated**: Executes for each outer row.  

**Scenario:**  
To find employees in IT department, I used a simple subquery. To compare employee salary with department average, I used correlated subquery.

---

## 3. Advanced SQL Questions

### Q15. ROWNUM vs ROW_NUMBER()  
**Definition:** Both assign row numbers.  

**Concept:**  
- **ROWNUM**: Pseudocolumn, assigned before ORDER BY.  
- **ROW_NUMBER()**: Analytic, assigns after ORDER BY.  

**Scenario:**  
To fetch first 10 rows quickly, I used ROWNUM. For pagination (ordered results), I used ROW_NUMBER().

---

### Q16. EXISTS vs IN  
**Definition:** Both check membership.  

**Concept:**  
- **IN**: Checks value in list. Good for small lists.  
- **EXISTS**: Returns TRUE if subquery has rows. Efficient for correlated queries.  

**Scenario:**  
For small filter lists, I used IN. For checking employee existence in departments, I used EXISTS (faster for large datasets).

---

### Q17. How to find the 2nd highest salary?  
**Concept:** Multiple methods.  

**Example:**  
```sql
-- Subquery
SELECT MAX(salary) FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);

-- Analytic
SELECT salary FROM (
  SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) AS rnk
  FROM employees
) WHERE rnk = 2;
```  

**Scenario:**  
I used analytic functions for ranking salaries and fetching 2nd/3rd highest directly in reporting queries.

---

### Q18. DELETE with WHERE vs Cascade Delete  
**Concept:**  
- **DELETE with WHERE**: Deletes chosen rows.  
- **Cascade Delete**: Automatically deletes dependent child rows.  

**Scenario:**  
When removing a department, I used CASCADE DELETE to automatically remove all employee rows linked to it.

---

### Q19. How to improve SQL performance?  
**Concept:**  
- Use indexes properly.  
- Avoid SELECT *.  
- Use bind variables.  
- Rewrite correlated subqueries as joins.  
- Partition large tables.  
- Analyze execution plan with DBMS_XPLAN.  

**Scenario:**  
A sales report query ran for 25 minutes; I added a composite index and rewrote correlated subquery as join. It ran in under 2 minutes.

---

### Q20. What is a CTE (WITH clause)?  
**Definition:** A Common Table Expression is a temporary named query.  

**Concept:**  
Improves readability and reusability.  

**Example:**  
```sql
WITH dept_avg AS (
   SELECT dept_id, AVG(salary) AS avg_sal
   FROM employees
   GROUP BY dept_id
)
SELECT e.name, e.salary, d.avg_sal
FROM employees e
JOIN dept_avg d ON e.dept_id = d.dept_id;
```  

**Scenario:**  
I used CTEs in ETL scripts to break complex queries into smaller logical blocks.

---

### Q21. MERGE statement  
**Definition:** MERGE = Insert + Update (UPSERT).  

**Concept:**  
Updates if row exists, inserts if not.  

**Scenario:**  
In data sync jobs, I merged staging data into master employee table daily using MERGE.

---

### Q22. PRIMARY KEY vs UNIQUE  
**Concept:**  
- **PRIMARY KEY**: One per table, enforces uniqueness + not null.  
- **UNIQUE**: Allows nulls, multiple allowed per table.  

**Scenario:**  
Employee table had PRIMARY KEY on emp_id, but UNIQUE constraint on email_id.

---

### Q23. Global Temporary Tables (GTT)  
**Definition:** Tables where data is session or transaction-specific.  

**Concept:**  
- Structure is permanent.  
- Data cleared on COMMIT or session end.  

**Scenario:**  
I used GTT for intermediate calculations in payroll — data cleared automatically after session.

---

### Q24. Sequences  
**Definition:** Schema object that generates unique numbers.  

**Concept:**  
- Used for primary keys.  
- NEXTVAL for next number, CURRVAL for current.  

**Scenario:**  
I used sequences for emp_id auto-generation during inserts.

---

### Q25. Hierarchical Queries in Oracle  
**Definition:** Queries that represent parent-child relationships.  

**Concept:**  
- Done with `CONNECT BY` and `START WITH`.  

**Example:**  
```sql
SELECT employee_id, manager_id, LEVEL
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;
```  

**Scenario:**  
I used hierarchical queries to generate org charts (employee → manager chain).

---


---

✅ Now both **SQL & PL/SQL docs are uniform** with **Definition → Concept → Scenario**.

Do you want me to **merge both into one master document** (SQL + PL/SQL, \~50 Q\&A) so you can prepare from a single source?
