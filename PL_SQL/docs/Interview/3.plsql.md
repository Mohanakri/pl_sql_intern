# PL/SQL Syntax Reference Guide with Definitions

## 1. BASIC BLOCK STRUCTURE

| Component | Definition | Syntax | When to Use |
|-----------|------------|--------|-------------|
| **Anonymous Block** | Basic unit of PL/SQL code without a name, consists of optional DECLARE, mandatory BEGIN, optional EXCEPTION, and mandatory END sections | ```sql<br>DECLARE<br>  -- variable declarations<br>BEGIN<br>  -- executable statements<br>EXCEPTION<br>  -- exception handlers<br>END;<br>/ ``` | For simple one-time scripts, testing code, or small tasks that don't need to be stored |
| **Named Block** | PL/SQL block with a label for identification and reference | ```sql<br><<block_name>><br>DECLARE<br>  -- declarations<br>BEGIN<br>  -- statements<br>END block_name; ``` | When you need to reference the block in GOTO statements or improve code readability |
| **Scope** | The visibility and accessibility of variables within different parts of the program | Variables declared in outer blocks are visible in inner blocks | Understanding where variables can be accessed and modified |
| **Lexical Scoping** | Rule determining variable visibility based on where variables are declared in nested blocks | Inner blocks can access outer block variables, but not vice versa | Preventing naming conflicts and controlling variable access |

## 2. VARIABLES AND DATATYPES

| Concept | Definition | Syntax | When to Use |
|---------|------------|--------|-------------|
| **Variable** | Named storage location that can hold data values, must be declared with a specific datatype | ```sql<br>variable_name datatype [NOT NULL] [:= initial_value];<br>-- Examples:<br>v_name VARCHAR2(50);<br>v_salary NUMBER(8,2) := 5000;<br>v_hire_date DATE NOT NULL := SYSDATE; ``` | To store values that can change during program execution |
| **Constant** | A variable whose value cannot be changed once assigned during declaration | ```sql<br>constant_name CONSTANT datatype := value;<br>-- Example:<br>c_tax_rate CONSTANT NUMBER := 0.08; ``` | For values that should never change (tax rates, limits, mathematical constants) |
| **Datatype** | Defines the type of data that can be stored in a variable (NUMBER, VARCHAR2, DATE, BOOLEAN, etc.) | ```sql<br>-- Scalar datatypes:<br>v_num NUMBER(10,2);<br>v_text VARCHAR2(100);<br>v_date DATE;<br>v_flag BOOLEAN; ``` | To ensure proper data storage and operations on variables |
| **%TYPE Attribute** | Allows a variable to inherit the datatype of a database column or another variable | ```sql<br>v_emp_name employees.first_name%TYPE;<br>v_copy_var v_original_var%TYPE; ``` | To ensure variable matches column datatype, maintains consistency when table structure changes |
| **%ROWTYPE Attribute** | Allows a variable to store an entire row from a table or cursor with the same structure | ```sql<br>v_emp_record employees%ROWTYPE;<br>v_cursor_rec cursor_name%ROWTYPE; ``` | To store complete row data, useful for copying/processing entire records efficiently |
| **Record** | Composite datatype that groups related data items together, similar to a row in a table | ```sql<br>TYPE emp_record_type IS RECORD (<br>  name VARCHAR2(50),<br>  salary NUMBER,<br>  hire_date DATE<br>);<br>v_emp emp_record_type; ``` | To group related data together when you need a custom structure different from existing tables |

## 3. CONTROL STRUCTURES

| Structure | Definition | Syntax | When to Use |
|-----------|------------|--------|-------------|
| **IF-THEN-ELSE** | Conditional logic structure that executes different code blocks based on conditions | ```sql<br>IF condition THEN<br>  statements;<br>ELSIF condition THEN<br>  statements;<br>ELSE<br>  statements;<br>END IF; ``` | For conditional logic with multiple branches or complex decision making |
| **CASE Statement** | Control structure that selects one of many code blocks to execute based on expression value | ```sql<br>CASE variable<br>  WHEN value1 THEN statement1;<br>  WHEN value2 THEN statement2;<br>  ELSE statement3;<br>END CASE;<br>-- Searched CASE:<br>CASE<br>  WHEN condition1 THEN statement1;<br>  WHEN condition2 THEN statement2;<br>END CASE; ``` | For multiple value-based conditions, cleaner and more readable than multiple IF statements |
| **Simple LOOP** | Basic loop structure that repeats until an EXIT condition is met | ```sql<br>LOOP<br>  statements;<br>  EXIT WHEN condition;<br>END LOOP; ``` | When you need at least one execution, or have complex exit conditions in the middle of loop |
| **WHILE LOOP** | Loop that continues as long as a condition remains true, condition checked before each iteration | ```sql<br>WHILE condition LOOP<br>  statements;<br>END LOOP; ``` | When condition needs to be checked before each iteration, may execute zero times |
| **FOR LOOP (Numeric)** | Loop that iterates a predetermined number of times using a counter variable | ```sql<br>FOR i IN 1..10 LOOP<br>  statements;<br>END LOOP;<br>-- Reverse:<br>FOR i IN REVERSE 1..10 LOOP<br>  statements;<br>END LOOP; ``` | For known number of iterations, automatic counter management |
| **FOR LOOP (Cursor)** | Simplified loop for processing cursor data, automatically handles cursor operations | ```sql<br>FOR rec IN cursor_name LOOP<br>  -- rec.column_name<br>  statements;<br>END LOOP;<br>-- Implicit cursor:<br>FOR rec IN (SELECT * FROM table) LOOP<br>  statements;<br>END LOOP; ``` | To process all rows from a cursor automatically without explicit open/fetch/close |
| **GOTO** | Statement that transfers control unconditionally to a labeled statement | ```sql<br><<label_name>><br>statements;<br>GOTO label_name; ``` | Generally discouraged, only for error handling or breaking out of nested loops |

## 4. CURSORS

| Cursor Type | Definition | Syntax | When to Use |
|-------------|------------|--------|-------------|
| **Cursor** | Pointer to a context area that holds the result set of a SQL query, allows row-by-row processing | Memory area for SQL query results | When processing query results row by row instead of all at once |
| **Implicit Cursor** | Automatically created cursor for SQL DML statements, Oracle manages it automatically | ```sql<br>SELECT column INTO variable FROM table<br>WHERE condition;<br>-- Cursor attributes:<br>SQL%FOUND, SQL%NOTFOUND<br>SQL%ROWCOUNT, SQL%ISOPEN ``` | For single-row SELECT INTO statements, DML operations (INSERT/UPDATE/DELETE) |
| **Explicit Cursor** | User-defined cursor that must be declared, opened, fetched from, and closed manually | ```sql<br>DECLARE<br>  CURSOR c_emp IS <br>    SELECT * FROM employees WHERE dept_id = 10;<br>  v_emp employees%ROWTYPE;<br>BEGIN<br>  OPEN c_emp;<br>  LOOP<br>    FETCH c_emp INTO v_emp;<br>    EXIT WHEN c_emp%NOTFOUND;<br>    -- process v_emp<br>  END LOOP;<br>  CLOSE c_emp;<br>END; ``` | When processing multiple rows, need cursor attributes, complex result sets, or want control over cursor lifecycle |
| **Cursor with Parameters** | Cursor that accepts input parameters to make it reusable with different values | ```sql<br>CURSOR c_emp(p_dept_id NUMBER, p_salary NUMBER) IS<br>  SELECT * FROM employees<br>  WHERE department_id = p_dept_id<br>  AND salary > p_salary;<br>-- Usage:<br>OPEN c_emp(10, 5000); ``` | To make cursors reusable with different filter values, improving code modularity |
| **REF CURSOR** | Cursor variable that can point to different result sets at runtime, providing flexibility | ```sql<br>TYPE ref_cursor IS REF CURSOR;<br>v_cursor ref_cursor;<br>-- Strongly typed:<br>TYPE emp_cursor IS REF CURSOR RETURN employees%ROWTYPE;<br>v_emp_cursor emp_cursor; ``` | For dynamic cursors, returning cursors from functions, or when cursor structure determined at runtime |
| **Cursor Attributes** | Properties that provide information about cursor status and processing results | ```sql<br>cursor_name%FOUND    -- TRUE if last fetch returned a row<br>cursor_name%NOTFOUND -- TRUE if last fetch found no row<br>cursor_name%ROWCOUNT -- Number of rows fetched so far<br>cursor_name%ISOPEN   -- TRUE if cursor is open ``` | To check cursor status, control loop processing, and get information about fetch operations |

## 5. EXCEPTION HANDLING

| Exception Type | Definition | Syntax | When to Use |
|----------------|------------|--------|-------------|
| **Exception** | Runtime error that occurs during program execution, can be predefined, user-defined, or pragma exceptions | Abnormal condition that disrupts normal program flow | To handle errors gracefully instead of program termination |
| **Exception Handling** | Mechanism to catch and handle errors using EXCEPTION block with WHEN clauses | ```sql<br>BEGIN<br>  statements;<br>EXCEPTION<br>  WHEN exception_name THEN<br>    handle_exception;<br>  WHEN OTHERS THEN<br>    handle_any_exception;<br>END; ``` | To handle predictable errors gracefully and provide meaningful error messages |
| **Predefined Exceptions** | Built-in exceptions provided by Oracle for common error conditions | ```sql<br>EXCEPTION<br>  WHEN NO_DATA_FOUND THEN<br>    -- SELECT INTO found no rows<br>  WHEN TOO_MANY_ROWS THEN<br>    -- SELECT INTO found multiple rows<br>  WHEN ZERO_DIVIDE THEN<br>    -- Division by zero attempted<br>  WHEN VALUE_ERROR THEN<br>    -- Conversion/constraint error<br>  WHEN DUP_VAL_ON_INDEX THEN<br>    -- Unique constraint violation<br>END; ``` | For handling common Oracle database errors with meaningful names |
| **User-Defined Exception** | Custom exceptions declared by programmer for business logic errors | ```sql<br>DECLARE<br>  invalid_salary EXCEPTION;<br>  negative_balance EXCEPTION;<br>BEGIN<br>  IF salary < 0 THEN<br>    RAISE invalid_salary;<br>  END IF;<br>EXCEPTION<br>  WHEN invalid_salary THEN<br>    DBMS_OUTPUT.PUT_LINE('Salary cannot be negative');<br>END; ``` | For business rule violations, custom validation errors, or application-specific conditions |
| **RAISE Statement** | Explicitly raises an exception in the program, can re-raise current exception | ```sql<br>RAISE exception_name;<br>RAISE; -- re-raises current exception ``` | To trigger exceptions based on business logic or to propagate exceptions to calling programs |
| **PRAGMA EXCEPTION_INIT** | Associates a user-defined exception name with a specific Oracle error number | ```sql<br>DECLARE<br>  duplicate_value EXCEPTION;<br>  PRAGMA EXCEPTION_INIT(duplicate_value, -1);<br>BEGIN<br>  -- statements that might cause ORA-00001<br>EXCEPTION<br>  WHEN duplicate_value THEN<br>    DBMS_OUTPUT.PUT_LINE('Record already exists');<br>END; ``` | To give meaningful names to Oracle error numbers for better code readability |

## 6. SUBPROGRAMS

| Type | Definition | Syntax | When to Use |
|------|------------|--------|-------------|
| **Procedure** | Named PL/SQL block that performs specific tasks, can accept parameters but doesn't return a value | ```sql<br>CREATE OR REPLACE PROCEDURE proc_name(<br>  p_param1 IN VARCHAR2,<br>  p_param2 OUT NUMBER,<br>  p_param3 IN OUT DATE<br>) IS<br>  -- local declarations<br>BEGIN<br>  -- procedure body<br>  p_param2 := 100; -- setting OUT parameter<br>END proc_name;<br>-- Calling:<br>EXECUTE proc_name('value', v_result, v_date); ``` | For reusable code that performs actions, may return multiple values through OUT parameters |
| **Function** | Named PL/SQL block that performs calculations and returns a single value through RETURN statement | ```sql<br>CREATE OR REPLACE FUNCTION func_name(<br>  p_param1 VARCHAR2,<br>  p_param2 NUMBER DEFAULT 0<br>) RETURN NUMBER IS<br>  v_result NUMBER;<br>BEGIN<br>  -- function body<br>  v_result := LENGTH(p_param1) + p_param2;<br>  RETURN v_result;<br>END func_name;<br>-- Calling:<br>v_length := func_name('Hello', 10); ``` | For reusable code that calculates and returns a single value, can be used in SQL statements |
| **Parameters** | Variables used to pass values into or out of procedures and functions | ```sql<br>-- IN: passes value to subprogram (default)<br>-- OUT: returns value from subprogram<br>-- IN OUT: passes value in and returns modified value<br>PROCEDURE example(<br>  p_input IN VARCHAR2,        -- input only<br>  p_output OUT NUMBER,        -- output only<br>  p_both IN OUT DATE          -- input and output<br>) ``` | To make subprograms flexible and reusable with different data values |
| **Local Subprogram** | Procedure or function defined within another PL/SQL block, only accessible within that block | ```sql<br>DECLARE<br>  PROCEDURE local_proc(p_val NUMBER) IS<br>  BEGIN<br>    DBMS_OUTPUT.PUT_LINE('Value: ' || p_val);<br>  END;<br>  <br>  FUNCTION local_func RETURN NUMBER IS<br>  BEGIN<br>    RETURN 42;<br>  END;<br>BEGIN<br>  local_proc(local_func);<br>END; ``` | For code reuse within a single block only, when functionality doesn't need global access |
| **Overloading** | Feature allowing multiple subprograms with same name but different parameter signatures | ```sql<br>CREATE OR REPLACE PACKAGE pkg IS<br>  PROCEDURE process_data(p_id NUMBER);<br>  PROCEDURE process_data(p_name VARCHAR2);<br>  PROCEDURE process_data(p_id NUMBER, p_name VARCHAR2);<br>END pkg; ``` | To provide different ways to call the same logical operation with different parameter types |
| **Forward Declaration** | Declaration of a subprogram before its actual definition, used to resolve mutual dependencies | ```sql<br>DECLARE<br>  -- Forward declaration<br>  PROCEDURE proc_b(p_val NUMBER);<br>  <br>  PROCEDURE proc_a(p_val NUMBER) IS<br>  BEGIN<br>    IF p_val > 0 THEN<br>      proc_b(p_val - 1);<br>    END IF;<br>  END;<br>  <br>  -- Actual definition<br>  PROCEDURE proc_b(p_val NUMBER) IS<br>  BEGIN<br>    proc_a(p_val);<br>  END;<br>BEGIN<br>  proc_a(5);<br>END; ``` | When two subprograms need to call each other (mutual recursion) |

## 7. PACKAGES

| Component | Definition | Syntax | When to Use |
|-----------|------------|--------|-------------|
| **Package** | Container that groups related procedures, functions, variables, and other constructs together | Modular programming unit that encapsulates related functionality | To organize code logically, provide data encapsulation, and improve performance |
| **Package Specification** | Public interface of a package that declares what can be accessed from outside the package | ```sql<br>CREATE OR REPLACE PACKAGE pkg_employee IS<br>  -- Public constants<br>  c_max_salary CONSTANT NUMBER := 100000;<br>  <br>  -- Public variables<br>  g_total_employees NUMBER;<br>  <br>  -- Public procedures and functions<br>  PROCEDURE hire_employee(p_name VARCHAR2);<br>  FUNCTION get_employee_count RETURN NUMBER;<br>  <br>  -- Public exception<br>  invalid_employee EXCEPTION;<br>END pkg_employee; ``` | To define public interface, group related functionality, hide implementation details |
| **Package Body** | Implementation of the package containing actual code for procedures and functions | ```sql<br>CREATE OR REPLACE PACKAGE BODY pkg_employee IS<br>  -- Private variables<br>  g_last_hire_date DATE;<br>  <br>  -- Private procedure<br>  PROCEDURE log_action(p_action VARCHAR2) IS<br>  BEGIN<br>    INSERT INTO audit_log VALUES (p_action, SYSDATE);<br>  END;<br>  <br>  -- Public procedure implementation<br>  PROCEDURE hire_employee(p_name VARCHAR2) IS<br>  BEGIN<br>    INSERT INTO employees (name) VALUES (p_name);<br>    g_total_employees := g_total_employees + 1;<br>    log_action('HIRED: ' || p_name);<br>  END;<br>  <br>  -- Public function implementation<br>  FUNCTION get_employee_count RETURN NUMBER IS<br>  BEGIN<br>    RETURN g_total_employees;<br>  END;<br>BEGIN<br>  -- Package initialization<br>  SELECT COUNT(*) INTO g_total_employees FROM employees;<br>END pkg_employee; ``` | To implement the functionality declared in package specification |

## 8. TRIGGERS

| Type | Definition | Syntax | When to Use |
|------|------------|--------|-------------|
| **Trigger** | Special PL/SQL block that automatically executes in response to specific database events | Stored program that runs automatically when certain events occur | For automatic data validation, auditing, logging, or enforcing business rules |
| **DML Trigger** | Trigger that fires in response to DML operations (INSERT, UPDATE, DELETE) on a table | ```sql<br>CREATE OR REPLACE TRIGGER trg_emp_audit<br>BEFORE UPDATE ON employees<br>FOR EACH ROW<br>BEGIN<br>  INSERT INTO emp_audit (<br>    emp_id, old_salary, new_salary, change_date<br>  ) VALUES (<br>    :NEW.employee_id, :OLD.salary, :NEW.salary, SYSDATE<br>  );<br>END;<br>-- Timing: BEFORE, AFTER, INSTEAD OF<br>-- Events: INSERT, UPDATE, DELETE<br>-- Level: FOR EACH ROW, statement level ``` | For auditing data changes, automatic column population, data validation before changes |
| **DDL Trigger** | Trigger that fires in response to DDL operations (CREATE, ALTER, DROP) on database objects | ```sql<br>CREATE OR REPLACE TRIGGER trg_ddl_audit<br>AFTER CREATE OR ALTER OR DROP<br>ON SCHEMA<br>BEGIN<br>  INSERT INTO ddl_audit (<br>    object_name, object_type, operation, change_date<br>  ) VALUES (<br>    ora_dict_obj_name, ora_dict_obj_type,<br>    ora_sysevent, SYSDATE<br>  );<br>END; ``` | For tracking schema changes, preventing unauthorized DDL operations |
| **System Trigger** | Trigger that fires in response to database system events like startup, shutdown, logon | ```sql<br>CREATE OR REPLACE TRIGGER trg_logon_audit<br>AFTER LOGON ON SCHEMA<br>BEGIN<br>  INSERT INTO user_sessions (<br>    username, logon_time, session_id<br>  ) VALUES (<br>    USER, SYSDATE, USERENV('SESSIONID')<br>  );<br>END; ``` | For user session tracking, security auditing, system monitoring |
| **OLD and NEW** | Correlation names used in DML triggers to reference old and new values of columns | ```sql<br>-- In row-level DML triggers:<br>:OLD.column_name  -- value before change<br>:NEW.column_name  -- value after change<br>-- Example:<br>IF :NEW.salary > :OLD.salary * 1.5 THEN<br>  RAISE_APPLICATION_ERROR(-20001, 'Salary increase too large');<br>END IF; ``` | To compare old and new values during data modifications |
| **Mutating Table** | Table that is being modified by a DML statement when a trigger tries to query or modify it | Error condition that prevents triggers from querying the table being modified | Understanding why certain operations fail in triggers, designing workarounds |

## 9. COLLECTIONS

| Type | Definition | Syntax | When to Use |
|------|------------|--------|-------------|
| **Collection** | Ordered group of elements of the same datatype, types include VARRAY, Nested Table, and Associative Array | Data structure for storing multiple values of same type | When working with sets of related data, bulk operations, or arrays |
| **VARRAY** | Variable-size array with a maximum limit on the number of elements, stored in database | ```sql<br>-- Declaration:<br>TYPE name_array IS VARRAY(10) OF VARCHAR2(50);<br>v_names name_array;<br>-- Usage:<br>v_names := name_array('John', 'Jane', 'Bob');<br>v_names.EXTEND; -- add space<br>v_names(4) := 'Alice';<br>-- Methods: COUNT, LIMIT, EXISTS, EXTEND, TRIM ``` | For small, fixed-maximum collections that need to be stored in database tables |
| **Nested Table** | Unbounded, ordered collection of elements that can be stored in database tables | ```sql<br>-- Declaration:<br>TYPE number_table IS TABLE OF NUMBER;<br>v_numbers number_table;<br>-- Usage:<br>v_numbers := number_table(1, 2, 3, 4, 5);<br>v_numbers.EXTEND;<br>v_numbers(6) := 10;<br>-- Methods: COUNT, EXISTS, EXTEND, TRIM, DELETE ``` | For large collections with no size limit, when you need to store in database |
| **Associative Array** | Index-by table that uses string or integer indexes to access elements | ```sql<br>-- Declaration:<br>TYPE emp_array IS TABLE OF employees%ROWTYPE<br>  INDEX BY PLS_INTEGER;<br>TYPE salary_array IS TABLE OF NUMBER<br>  INDEX BY VARCHAR2(50);<br>-- Usage:<br>v_emps emp_array;<br>v_salaries salary_array;<br>v_emps(1) := employee_record;<br>v_salaries('SMITH') := 5000; ``` | For in-memory processing, when you need key-value pairs, or sparse arrays |

## 10. BULK OPERATIONS

| Operation | Definition | Syntax | When to Use |
|-----------|------------|--------|-------------|
| **BULK COLLECT** | Feature that allows fetching multiple rows at once from cursor into collection, improving performance | ```sql<br>DECLARE<br>  TYPE name_array IS TABLE OF employees.first_name%TYPE;<br>  v_names name_array;<br>  CURSOR c_emp IS SELECT first_name FROM employees;<br>BEGIN<br>  -- Fetch all rows at once<br>  OPEN c_emp;<br>  FETCH c_emp BULK COLLECT INTO v_names;<br>  CLOSE c_emp;<br>  -- Process collection<br>  FOR i IN 1..v_names.COUNT LOOP<br>    DBMS_OUTPUT.PUT_LINE(v_names(i));<br>  END LOOP;<br>END;<br>-- With LIMIT:<br>FETCH cursor_name BULK COLLECT INTO collection LIMIT 1000; ``` | When processing large result sets to reduce context switching between PL/SQL and SQL engines |
| **FORALL** | Statement that performs bulk DML operations on collections, processing multiple rows efficiently | ```sql<br>DECLARE<br>  TYPE id_array IS TABLE OF employees.employee_id%TYPE;<br>  v_ids id_array;<br>BEGIN<br>  -- Populate collection<br>  SELECT employee_id BULK COLLECT INTO v_ids<br>  FROM employees WHERE department_id = 10;<br>  <br>  -- Bulk delete<br>  FORALL i IN 1..v_ids.COUNT<br>    DELETE FROM employees WHERE employee_id = v_ids(i);<br>    <br>  -- Bulk insert<br>  FORALL i IN v_new_emps.FIRST..v_new_emps.LAST<br>    INSERT INTO employees VALUES v_new_emps(i);<br>END; ``` | For high-performance DML operations on collections, significantly faster than row-by-row processing |

## 11. TRANSACTION CONTROL

| Statement | Definition | Syntax | When to Use |
|-----------|------------|--------|-------------|
| **COMMIT** | Makes all changes in the current transaction permanent and releases locks | ```sql<br>BEGIN<br>  INSERT INTO table1 VALUES (...);<br>  UPDATE table2 SET ...;<br>  COMMIT; -- makes changes permanent<br>END; ``` | To permanently save changes when you're confident all operations succeeded |
| **ROLLBACK** | Undoes all changes made in current transaction and releases locks | ```sql<br>BEGIN<br>  INSERT INTO table1 VALUES (...);<br>  IF error_condition THEN<br>    ROLLBACK; -- undo all changes<br>  ELSE<br>    COMMIT;<br>  END IF;<br>END; ``` | To undo changes when errors occur or conditions aren't met |
| **SAVEPOINT** | Named point in transaction to which you can roll back without rolling back entire transaction | ```sql<br>BEGIN<br>  INSERT INTO table1 VALUES (...);<br>  SAVEPOINT sp1;<br>  UPDATE table2 SET ...;<br>  IF error_condition THEN<br>    ROLLBACK TO sp1; -- undo only UPDATE<br>  END IF;<br>  COMMIT;<br>END; ``` | For partial rollbacks in complex transactions with multiple steps |
| **PRAGMA AUTONOMOUS_TRANSACTION** | Directive that makes a subprogram execute in its own independent transaction | ```sql<br>CREATE OR REPLACE PROCEDURE log_error(<br>  p_error VARCHAR2<br>) IS<br>PRAGMA AUTONOMOUS_TRANSACTION;<br>BEGIN<br>  INSERT INTO error_log VALUES (p_error, SYSDATE);<br>  COMMIT; -- independent of calling transaction<br>END; ``` | For logging that should persist even if main transaction rolls back |

## 12. DYNAMIC SQL

| Feature | Definition | Syntax | When to Use |
|---------|------------|--------|-------------|
| **EXECUTE IMMEDIATE** | Executes dynamically constructed SQL statements at runtime | ```sql<br>DECLARE<br>  v_sql VARCHAR2(1000);<br>  v_table_name VARCHAR2(30) := 'employees';<br>  v_count NUMBER;<br>BEGIN<br>  -- Dynamic query<br>  v_sql := 'SELECT COUNT(*) FROM ' || v_table_name;<br>  EXECUTE IMMEDIATE v_sql INTO v_count;<br>  <br>  -- Dynamic DML with parameters<br>  v_sql := 'UPDATE ' || v_table_name || <br>           ' SET salary = salary * :1 WHERE dept_id = :2';<br>  EXECUTE IMMEDIATE v_sql USING 1.1, 10;<br>END; ``` | When SQL statements need to be constructed at runtime based on conditions or user input |

## 13. PERFORMANCE FEATURES

| Feature | Definition | Syntax | When to Use |
|---------|------------|--------|-------------|
| **Pipelined Function** | Function that returns rows as they are produced rather than building entire result set first | ```sql<br>CREATE OR REPLACE FUNCTION get_employees<br>RETURN sys.odcinumberlist PIPELINED IS<br>BEGIN<br>  FOR rec IN (SELECT employee_id FROM employees) LOOP<br>    PIPE ROW(rec.employee_id);<br>  END LOOP;<br>  RETURN;<br>END;<br>-- Usage in SQL:<br>SELECT * FROM TABLE(get_employees()); ``` | For memory-efficient processing of large result sets, especially in ETL operations |
| **Deterministic Function** | Function that always returns the same result for the same input parameters | ```sql<br>CREATE OR REPLACE FUNCTION calculate_tax(<br>  p_salary NUMBER<br>) RETURN NUMBER DETERMINISTIC IS<br>BEGIN<br>  RETURN p_salary * 0.15;<br>END;<br>-- Oracle can cache results for same inputs ``` | When function results can be cached for performance, pure mathematical calculations |
| **Parallel Enable** | Hint that allows a function to be executed in parallel during query processing | ```sql<br>CREATE OR REPLACE FUNCTION process_data(<br>  p_value NUMBER<br>) RETURN NUMBER<br>PARALLEL_ENABLE IS<br>BEGIN<br>  RETURN p_value * 2;<br>END; ``` | For functions used in SELECT statements that can benefit from parallel execution |